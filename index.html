<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Note Taker</title>
    <!--
      AstroMind-Demo single-file application
      - Vision: Analog Sci‑Fi aesthetic (CRT vibes, frosty glass UI) supporting spatial cognition
      - Engine: Three.js (no bundler). Persistence via localStorage only. Deployed as a static page.
      - Interaction: WASD/QE + mouse, Tab to cycle planets, click planets to open on-planet UI.
      - Accessibility: UI disables navigation when typing; distance-based UI auto-hide reduces clutter.
      Editing: All logic lives here. Reload the page after edits.
    -->
    <style>
        /* ===============================
           Base + Global Aesthetic
           =============================== */
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            overflow: hidden;
            background-color: #000005;
            color: #333;
        }
        /* Full-screen WebGL mount */
        #scene-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            cursor: grab;
        }
        #scene-container:focus {
            outline: none; /* Removes the blue outline on focus */
        }

        /* ===============================
           Note Editor Panel (frosty glass)
           =============================== */
        .note-editor {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 300px;
            min-width: 250px; /* Minimum resize width */
            min-height: 250px; /* Minimum resize height */
            background: rgba(255, 255, 255, 0.1);
            border-radius: 0; /* Square corners */
            box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.37);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            border: 1px solid rgba(255, 255, 255, 0.5);
            padding-top: 30px; /* Make space for drag handle and close button */
            display: none;
            flex-direction: column;
            gap: 15px;
            max-height: calc(100vh - 40px);
            overflow: hidden; /* Changed from auto to hidden for resize */
            z-index: 1000;
            transform-origin: center;
        }

        /* CRT "power-off" close animation for note editor */
        .note-editor.closing {
            animation: crt-flicker-out 400ms forwards;
        }

        .note-editor.closing > * {
            visibility: hidden; /* Hide content during animation */
        }

        @keyframes crt-flicker-out {
            0% { transform: scale(1, 1); background-color: rgba(255, 255, 255, 0.1); backdrop-filter: blur(8px); -webkit-backdrop-filter: blur(8px); }
            40% { transform: scale(1, 0.01); background-color: white; backdrop-filter: blur(0px); -webkit-backdrop-filter: blur(0px); }
            80% { transform: scale(0.005, 0.005); background-color: white; }
            100% { transform: scale(0, 0); background-color: white; }
        }

        /* Drag handle targets mouse movement only (no visible chrome) */
        .note-editor .drag-handle {
            position: absolute;
            top: 0;
            left: 0;
            width: calc(100% - 30px); /* Leave space for close button */
            height: 30px;
            cursor: move;
        }

        .note-editor .note-title {
            font-size: 1.2em;
            font-weight: bold;
            color: #fff;
            border: none;
            background: transparent;
            border-bottom: 2px solid rgba(255, 255, 255, 0.5);
            padding: 8px 0;
            transition: border-color 0.3s;
            flex-shrink: 0;
            margin: 0 20px; /* Add margin to align with padding */
        }
        .note-editor .note-title:focus { outline: none; border-bottom-color: #fff; }
        .note-editor .note-title::placeholder { color: rgba(255, 255, 255, 0.7); }

        .note-editor .note-content {
            font-size: 1em;
            min-height: 150px;
            resize: none;
            background: rgba(255, 255, 255, 0.2);
            color: #fff;
            border: 1px solid rgba(255, 255, 255, 0.5);
            border-radius: 0; /* Square corners */
            padding: 10px;
            transition: border-color 0.3s, box-shadow 0.3s;
            flex-grow: 1;
            margin: 0 20px;
        }
        .note-editor .note-content:focus { outline: none; border-color: #fff; box-shadow: 0 0 5px rgba(255, 255, 255, 0.5); }
        .note-editor .note-content::placeholder { color: rgba(255, 255, 255, 0.7); }
        /* Action buttons in note editor */
        .button-group {
            display: flex;
            justify-content: flex-end; /* Align buttons to the right */
            gap: 10px;
            flex-shrink: 0;
            margin: 0 20px;
            padding-bottom: 20px;
        }

        .btn {
            padding: 10px 15px;
            border: 1px solid rgba(255, 255, 255, 0.5);
            border-radius: 0; /* Square corners */
            cursor: pointer;
            font-weight: bold;
            transition: background-color 0.3s, transform 0.2s;
            background-color: rgba(255, 255, 255, 0.4);
            color: #fff;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-grow: 0;
            flex-shrink: 0;
        }

        .btn:hover {
            background-color: rgba(255, 255, 255, 0.6);
            transform: translateY(-2px);
        }

        .note-editor .note-save-btn {
            background-color: rgba(40, 167, 69, 0.7);
            border-color: rgba(40, 167, 69, 1);
        }
        .note-editor .note-save-btn:hover {
             background-color: rgba(33, 136, 56, 0.9);
        }

        .note-editor .note-delete-btn, #delete-planet-btn {
            background-color: rgba(220, 53, 69, 0.7);
            border-color: rgba(220, 53, 69, 1);
        }
        .note-editor .note-delete-btn:hover, #delete-planet-btn:hover {
            background-color: rgba(200, 48, 62, 0.9);
        }
        .note-delete-btn svg { width: 1.2em; height: 1.2em; }
        #delete-planet-btn { display: flex; align-items: center; gap: 6px; margin-right: auto; }
        #delete-planet-btn svg { width: 16px; height: 16px; }

        /* Global "Create Planet" CTA */
        #add-planet-btn {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 12px 25px;
            background-color: #28a745;
            color: white;
            border: none;
            border-radius: 30px;
            font-size: 1em;
            font-weight: bold;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            cursor: pointer;
            transition: background-color 0.3s, transform 0.2s;
            z-index: 1001;
        }
        #add-planet-btn:hover { background-color: #218838; transform: translateX(-50%) translateY(-2px); }

        /* On-screen input help (non-blocking) */
        .instructions { position: fixed; top: 20px; left: 20px; background: rgba(0, 0, 0, 0.6); color: white; padding: 10px 15px; border-radius: 8px; font-size: 0.9em; }

        /* ===============================
           Modal (confirm destructive action)
           =============================== */
        .modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.6); display: flex; justify-content: center; align-items: center; z-index: 3000; }
        .modal-content {
            background: rgba(20, 20, 30, 0.9);
            color: white;
            padding: 25px;
            border-radius: 0;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            text-align: center;
            width: 90%;
            max-width: 400px;
            border: 1px solid rgba(255, 255, 255, 0.5);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            z-index: 3001;
        }
        .modal-buttons { display: flex; justify-content: center; gap: 15px; margin-top: 20px; }
        .modal-content h3 { margin: 0 0 15px 0; color: #fff; font-weight: 600; }
        .modal-input {
            width: 100%;
            padding: 10px;
            font-size: 1em;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.5);
            border-radius: 0;
            color: #fff;
            transition: border-color 0.3s, box-shadow 0.3s;
        }
        .modal-input:focus {
            outline: none;
            border-color: rgba(255, 255, 255, 0.9);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.15);
        }
        .input-error {
            border-color: rgba(220, 53, 69, 1) !important;
            box-shadow: 0 0 0 2px rgba(220, 53, 69, 0.4) !important;
        }
        #modal-confirm-btn { background-color: rgba(220, 53, 69, 0.7); border-color: rgba(220, 53, 69, 1); }
        #modal-confirm-btn:hover { background-color: rgba(200, 48, 62, 0.9); }
        #modal-cancel-btn { background-color: rgba(255, 255, 255, 0.2); border-color: rgba(255,255,255,0.5); }
        #modal-cancel-btn:hover { background-color: rgba(255, 255, 255, 0.4); }
        #name-prompt-confirm-btn { background-color: rgba(40, 167, 69, 0.7); border-color: rgba(40, 167, 69, 1); }
        #name-prompt-confirm-btn:hover { background-color: rgba(33, 136, 56, 0.9); }
        #name-prompt-cancel-btn { background-color: rgba(255, 255, 255, 0.2); border-color: rgba(255,255,255,0.5); }
        #name-prompt-cancel-btn:hover { background-color: rgba(255, 255, 255, 0.4); }

        /* Editor resize affordances */
        .note-editor .resize-handle {
            position: absolute;
            width: 18px;
            height: 18px;
            z-index: 1001;
            pointer-events: auto;
            transition: filter 0.2s ease;
        }
        .note-editor .resize-handle-bl {
            bottom: 5px;
            left: 5px;
            cursor: nesw-resize;
            background: linear-gradient(225deg, transparent 50%, rgba(255, 255, 255, 0.75) 50%);
        }
        .note-editor .resize-handle-br {
            bottom: 5px;
            right: 5px;
            cursor: nwse-resize;
            background: linear-gradient(135deg, transparent 50%, rgba(255, 255, 255, 0.75) 50%);
        }
        .note-editor .resize-handle-bl:hover, .note-editor .resize-handle-br:hover {
            filter: brightness(1.25);
        }

        /* Minimal close icon (kept simple for readability & CRT feel) */
        .note-editor .note-close-btn { position: absolute; top: 5px; right: 5px; width: 20px; height: 20px; cursor: pointer; opacity: 0.8; transition: opacity 0.2s; }
        .note-editor .note-close-btn:hover { opacity: 1; }
        .note-editor .note-close-btn::before, .note-editor .note-close-btn::after { content: ''; position: absolute; top: 9px; left: 2px; width: 16px; height: 2px; background-color: #fff; }
        .note-editor .note-close-btn::before { transform: rotate(45deg); }
        .note-editor .note-close-btn::after { transform: rotate(-45deg); }
        #planet-close-btn { position: absolute; top: 8px; right: 10px; width: 18px; height: 18px; cursor: pointer; opacity: 0.75; transition: opacity 0.2s; }
        #planet-close-btn:hover { opacity: 1; }
        #planet-close-btn::before, #planet-close-btn::after { content: ''; position: absolute; top: 8px; left: 2px; width: 14px; height: 2px; background-color: #fff; }
        #planet-close-btn::before { transform: rotate(45deg); }
        #planet-close-btn::after { transform: rotate(-45deg); }

        /* ===============================
           On-planet UI card (CSS2D label)
           =============================== */
        .planet-ui {
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px;
            border: 1px solid rgba(255,255,255,0.4);
            width: 200px;
            pointer-events: auto !important;
            cursor: default;
        }
        .planet-ui-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid rgba(255,255,255,0.4);
            padding-bottom: 5px;
            margin-bottom: 5px;
        }
        .planet-ui-header h3 { margin: 0; font-size: 1.2em; }
        .edit-planet-btn { background: none; border: none; color: white; cursor: pointer; padding: 2px; }
        .edit-planet-btn svg { width: 16px; height: 16px; }
        .notes-list { list-style: none; padding: 0; margin: 0; }
        .notes-list li { padding: 5px; cursor: pointer; border-bottom: 1px solid rgba(255,255,255,0.2); }
        .notes-list li:hover { background: rgba(255,255,255,0.2); }
        .notes-list li:last-child { border-bottom: none; }
        .add-note-btn { background: rgba(255,255,255,0.2); border: none; color: white; width: 100%; padding: 5px; margin-top: 5px; cursor: pointer; transition: background-color 0.2s ease, transform 0.2s ease, box-shadow 0.2s ease; }
        .add-note-btn:hover, .add-note-btn:focus { background: rgba(255,255,255,0.35); transform: translateY(-1px); box-shadow: 0 0 6px rgba(255,255,255,0.25); outline: 2px solid rgba(255,255,255,0.7); outline-offset: 2px; }

        /* Planet edit panel (planet properties) */
        #planet-edit-panel {
             position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 300px;
            background: rgba(20, 20, 30, 0.9);
            border-radius: 0;
            box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.37);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            border: 1px solid rgba(255, 255, 255, 0.5);
            padding: 20px;
            display: none;
            flex-direction: column;
            gap: 15px;
            z-index: 1002;
            color: white;
        }
        .form-group { display: flex; flex-direction: column; gap: 5px; }
        .form-group input, .form-group select { background: rgba(255, 255, 255, 0.2); color: #fff; border: 1px solid rgba(255, 255, 255, 0.5); padding: 8px; }
        .form-group select option { color: black; background-color: white; }
        .form-group input[type="color"] { padding: 2px; height: 35px; }
        
        /* Screen-space connector line from editor to focused planet */
        .note-connector {
            position: fixed;
            height: 2px;
            background-color: #000;
            transform-origin: 0 50%;
            pointer-events: none;
            display: none;
            z-index: 998;
            box-shadow: 0 0 0 1px rgba(255, 255, 255, 0.4);
        }
    </style>
    
        <!-- Editable settings (single-file friendly). You can tweak values below. -->
            <script type="application/json" id="app-settings">
            {
                "cycle": {
                    "durationMs": 350,
                    "distance": 10,
                    "easing": "easeInOutCubic"
                },
                "movement": {
                    "moveSpeed": 0.1,
                    "damping": 0.93
                },
                        "controls": {
                            "enableDamping": true,
                            "dampingFactor": 0.05,
                            "minDistance": 3,
                            "maxDistance": 50,
                            "maxPolarAngle": 1.494
                        },
                "post": {
                    "filmNoise": 0.3,
                    "filmScanlineIntensity": 0.2,
                    "filmScanlineCount": 1024,
                    "filmGrayscale": false,
                    "rgbOffset": 0.0015,
                    "vignetteStart": 0.4,
                    "vignetteEnd": 0.9
                },
                "ui": {
                    "labelHideDistance": 20,
                    "showConnector": true
                },
                "notes": {
                    "decalSize": 0.75,
                    "decalOpacity": 0.9
                }
            }
            </script>
</head>
<body>
    <!-- WebGL mount and 2D overlay renderers attach to this container -->
    <div id="scene-container" tabindex="0"></div>
    <div id="note-editors-root"></div>
    <template id="note-editor-template">
        <div class="note-editor" style="display: none;">
            <div class="drag-handle"></div>
            <div class="note-close-btn" title="Close"></div>
            <input type="text" class="note-title" placeholder="Note Title">
            <textarea class="note-content" placeholder="Write your note here..."></textarea>
            <div class="button-group">
                <button class="btn note-save-btn">Save</button>
                <button class="btn note-delete-btn" title="Delete">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                        <path d="M5.5 5.5A.5.5 0 0 1 6 6v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5m2.5 0a.5.5 0 0 1 .5.5v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5m3 .5a.5.5 0 0 0-1 0v6a.5.5 0 0 0 1 0z"/>
                        <path d="M14.5 3a1 1 0 0 1-1 1H13v9a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V4h-.5a1 1 0 0 1-1-1V2a1 1 0 0 1 1-1H6a1 1 0 0 1 1-1h2a1 1 0 0 1 1 1h3.5a1 1 0 0 1 1 1zM4.118 4 4 4.059V13a1 1 0 0 0 1 1h6a1 1 0 0 0 1-1V4.059L11.882 4zM2.5 3V2h11v1z"/>
                    </svg>
                </button>
            </div>
            <div class="resize-handle resize-handle-bl"></div>
            <div class="resize-handle resize-handle-br"></div>
        </div>
    </template>

    <!-- Lightweight instructions overlay to reduce cognitive load for first-time users -->
    <div class="instructions">
        <p>Use WASD/Arrow keys to move.</p>
        <p>Q/E to move vertically.</p>
        <p>Tab to cycle between planets.</p>
        <p>Click a planet to view its notes.</p>
        <p>UI hides when you move away.</p>
    </div>
    <!-- Note editors are instantiated from the template above -->
    <!-- Edit currently selected planet's geometry, name, and color -->
    <div id="planet-edit-panel">
        <div id="planet-close-btn" title="Cancel"></div>
        <h3>Edit Planet</h3>
        <div class="form-group">
            <label for="planet-name-input">Name</label>
            <input type="text" id="planet-name-input">
        </div>
        <div class="form-group">
            <label for="shape-type-select">Shape</label>
            <select id="shape-type-select">
                <option value="Box">Box</option>
                <option value="Sphere">Sphere</option>
                <option value="Cone">Cone</option>
                <option value="Torus">Torus</option>
            </select>
        </div>
         <div class="form-group">
            <label for="planet-color-input">Color</label>
            <input type="color" id="planet-color-input" value="#ffffff">
        </div>
        <div class="button-group">
            <button id="delete-planet-btn" class="btn" title="Delete Planet">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                    <path d="M5.5 5.5A.5.5 0 0 1 6 6v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5m2.5 0a.5.5 0 0 1 .5.5v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5m3 .5a.5.5 0 0 0-1 0v6a.5.5 0 0 0 1 0z"/>
                    <path d="M14.5 3a1 1 0 0 1-1 1H13v9a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V4h-.5a1 1 0 0 1-1-1V2a1 1 0 0 1 1-1H6a1 1 0 0 1 1-1h2a1 1 0 0 1 1 1h3.5a1 1 0 0 1 1 1zM4.118 4 4 4.059V13a1 1 0 0 0 1 1h6a1 1 0 0 0 1-1V4.059L11.882 4zM2.5 3V2h11v1z"/>
                </svg>
                Delete
            </button>
            <button id="save-planet-btn" class="btn">Save</button>
            <button id="close-planet-edit-btn" class="btn">Cancel</button>
        </div>
    </div>

    <button id="add-planet-btn">Create Planet</button>

    <!-- Destructive action confirmation modal -->
    <div id="confirm-modal" class="modal-overlay" style="display: none;">
        <div class="modal-content">
            <p id="confirm-message">Are you sure?</p>
            <div class="modal-buttons">
                <button id="modal-confirm-btn" class="btn">Yes, Delete</button>
                <button id="modal-cancel-btn" class="btn">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Generic name prompt modal for new planets and notes -->
    <div id="name-prompt-modal" class="modal-overlay" style="display: none;">
        <div class="modal-content">
            <h3 id="name-prompt-title">Name Item</h3>
            <input id="name-prompt-input" class="modal-input" type="text" autocomplete="off">
            <div class="modal-buttons">
                <button id="name-prompt-confirm-btn" class="btn">Save</button>
                <button id="name-prompt-cancel-btn" class="btn">Cancel</button>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/renderers/CSS2DRenderer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/FilmShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/FilmPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/geometries/DecalGeometry.js"></script>
    
    <script type="module">
        // =================================================================================
        // Overview
        // =================================================================================
        /**
         * Spatial note-taking demo with an Analog Sci‑Fi aesthetic.
         * - All state is persisted to localStorage as a Map of planetId -> PlanetData.
         * - 3D planets have on-planet UI (CSS2D labels). A separate draggable editor handles note content.
         * - Keyboard navigation (WASD/QE) is disabled while typing to support focus and accessibility.
         */

        // =================================================================================
        // SECTION: GLOBAL VARIABLES & STATE
        // =================================================================================
    /** @type {THREE.Scene} */
    let scene, camera, renderer, controls, raycaster, mouse, composer, clock, labelRenderer, filmPass, decalMaterial, retroPass;
        /** Map of planetId -> THREE.Mesh (with .label: CSS2DObject) */
        const planets = new Map();
        const decals = new Map();
        // Selection + UI state
        // Selection and UI state
        let selectedPlanet = null;
        let editingPlanet = null;
        let lastIntersection = null;
        let pendingNoteOpen = null;
        let isDraggingCamera = false;
        /** Map of `${planetId}:${noteIndex}` -> editor state */
        const openEditors = new Map();
        let nextEditorZ = 1100;
        let activePlanetUI = null, cycleIndex = -1, isCycling = false;
    const keyState = {};
    let isTyping = false;
    // Settings state
    let SETTINGS = {};
    // Movement parameters (initialized from settings in init())
    let moveSpeed = 0.1, DAMPING = 0.93; // Simple momentum for camera movement
        let cameraVelocity = new THREE.Vector3();
        // DOM refs split for readability (was a single chained declaration)
        const sceneContainer = document.getElementById('scene-container');
        const editorsRoot = document.getElementById('note-editors-root');
        const noteEditorTemplate = document.getElementById('note-editor-template');
        const addPlanetBtn = document.getElementById('add-planet-btn');
    const confirmModal = document.getElementById('confirm-modal');
    const confirmMessage = document.getElementById('confirm-message');
        const modalConfirmBtn = document.getElementById('modal-confirm-btn');
        const modalCancelBtn = document.getElementById('modal-cancel-btn');
        const planetEditPanel = document.getElementById('planet-edit-panel');
        const planetCloseBtn = document.getElementById('planet-close-btn');
        const planetNameInput = document.getElementById('planet-name-input');
        const shapeTypeSelect = document.getElementById('shape-type-select');
        const planetColorInput = document.getElementById('planet-color-input');
        const deletePlanetBtn = document.getElementById('delete-planet-btn');
        const savePlanetBtn = document.getElementById('save-planet-btn');
        const closePlanetEditBtn = document.getElementById('close-planet-edit-btn');
        const namePromptModal = document.getElementById('name-prompt-modal');
        const namePromptTitle = document.getElementById('name-prompt-title');
        const namePromptInput = document.getElementById('name-prompt-input');
        const namePromptConfirmBtn = document.getElementById('name-prompt-confirm-btn');
        const namePromptCancelBtn = document.getElementById('name-prompt-cancel-btn');
        let deleteAction = null;
        let activeNamePrompt = null;
        let wasTypingBeforePrompt = false;
        let wasTypingBeforePlanetEdit = false;

        planetNameInput.addEventListener('input', () => {
            if (planetNameInput.classList.contains('input-error')) {
                planetNameInput.classList.remove('input-error');
            }
        });
        
        // =================================================================================
        // SECTION: SETTINGS LOADER (single-file + localStorage overrides)
        // =================================================================================
        const SETTINGS_STORAGE_KEY = 'astroMind-settings-overrides';
        function deepMerge(target, src) {
            const out = Array.isArray(target) ? [...target] : { ...target };
            for (const [k, v] of Object.entries(src || {})) {
                if (v && typeof v === 'object' && !Array.isArray(v)) {
                    out[k] = deepMerge(out[k] || {}, v);
                } else {
                    out[k] = v;
                }
            }
            return out;
        }
        function loadSettings() {
            try {
                const tag = document.getElementById('app-settings');
                const base = tag ? JSON.parse(tag.textContent) : {};
                const overridesStr = localStorage.getItem(SETTINGS_STORAGE_KEY);
                const overrides = overridesStr ? JSON.parse(overridesStr) : {};
                SETTINGS = deepMerge(base, overrides);
            } catch (e) {
                console.warn('Failed to load settings, using defaults', e);
                SETTINGS = { cycle: { durationMs: 350, distance: 10, easing: 'easeInOutCubic' }, movement: { moveSpeed: 0.1, damping: 0.93 } };
            }
        }
        function getSetting(path, fallback) {
            const parts = path.split('.');
            let cur = SETTINGS;
            for (const p of parts) {
                if (cur && Object.prototype.hasOwnProperty.call(cur, p)) cur = cur[p];
                else return fallback;
            }
            return cur;
        }
        function saveSettingsOverrides(partial) {
            const overridesStr = localStorage.getItem(SETTINGS_STORAGE_KEY);
            const overrides = overridesStr ? JSON.parse(overridesStr) : {};
            const newOverrides = deepMerge(overrides, partial);
            localStorage.setItem(SETTINGS_STORAGE_KEY, JSON.stringify(newOverrides));
            SETTINGS = deepMerge(SETTINGS, partial);
        }
        function applySettings() {
            // Movement
            moveSpeed = getSetting('movement.moveSpeed', moveSpeed);
            DAMPING = getSetting('movement.damping', DAMPING);
            // Controls
            if (controls) {
                controls.enableDamping = getSetting('controls.enableDamping', controls.enableDamping);
                controls.dampingFactor = getSetting('controls.dampingFactor', controls.dampingFactor);
                controls.minDistance = getSetting('controls.minDistance', controls.minDistance);
                controls.maxDistance = getSetting('controls.maxDistance', controls.maxDistance);
                controls.maxPolarAngle = getSetting('controls.maxPolarAngle', controls.maxPolarAngle);
                controls.update();
            }
            // Post effects
            if (filmPass) {
                filmPass.uniforms.nIntensity.value = getSetting('post.filmNoise', filmPass.uniforms.nIntensity.value);
                filmPass.uniforms.sIntensity.value = getSetting('post.filmScanlineIntensity', filmPass.uniforms.sIntensity.value);
                filmPass.uniforms.sCount.value = getSetting('post.filmScanlineCount', filmPass.uniforms.sCount.value);
                filmPass.uniforms.grayscale.value = getSetting('post.filmGrayscale', filmPass.uniforms.grayscale.value);
            }
            // Retro shader pass uniforms (if exists)
            if (typeof retroPass !== 'undefined' && retroPass && retroPass.uniforms) {
                retroPass.uniforms.rgbOffset.value = getSetting('post.rgbOffset', retroPass.uniforms.rgbOffset.value);
                retroPass.uniforms.vigStart.value = getSetting('post.vignetteStart', retroPass.uniforms.vigStart.value);
                retroPass.uniforms.vigEnd.value = getSetting('post.vignetteEnd', retroPass.uniforms.vigEnd.value);
            }
            // Decals: update opacity live
            for (const [id, decal] of decals.entries()) {
                if (decal && decal.material) {
                    decal.material.opacity = getSetting('notes.decalOpacity', decal.material.opacity);
                    decal.material.needsUpdate = true;
                }
            }
        }
        // Small API for runtime tweaks from DevTools
        window.AstroMind = {
            get settings() { return SETTINGS; },
            set(partial) {
                saveSettingsOverrides(partial);
                applySettings();
            },
            resetSettings() {
                localStorage.removeItem(SETTINGS_STORAGE_KEY);
                loadSettings();
                applySettings();
            },
        };

        // =================================================================================
        // SECTION: LOCAL STORAGE PERSISTENCE
        // =================================================================================
        /**
         * Storage key for serializing the scene graph state to localStorage
         */
        const STORAGE_KEY = 'astroMind-scene-data'; // Kept stable to preserve existing localStorage saves
        /**
         * @typedef {{title: string, content: string}} Note
         * @typedef {{x:number,y:number,z:number}} Vec3Plain
         * @typedef {{position: Vec3Plain, orientation: {x:number,y:number,z:number}}} DecalData
         * @typedef {{
         *   name: string,
         *   shape: 'Box'|'Sphere'|'Cone'|'Torus',
         *   color: string,
         *   position: Vec3Plain,
         *   notes: Note[],
         *   decal: DecalData|null
         * }} PlanetData
         * @type {Map<string, PlanetData>}
         */
        let sceneData = new Map();

        /** Load Map<string, PlanetData> from localStorage (if any). */
        function loadDataFromStorage() {
            const dataString = localStorage.getItem(STORAGE_KEY);
            if (dataString) {
                try {
                    const dataArray = JSON.parse(dataString);
                    sceneData = new Map(dataArray);
                } catch(e) {
                    console.error("Error parsing data from localStorage:", e);
                    sceneData = new Map();
                }
            } else {
                sceneData = new Map();
            }
        }

        /** Persist Map<string, PlanetData> to localStorage. */
        function saveDataToStorage() {
            try {
                const dataArray = Array.from(sceneData.entries());
                localStorage.setItem(STORAGE_KEY, JSON.stringify(dataArray));
            } catch(e) {
                console.error("Error saving data to localStorage:", e);
            }
        }

        // =================================================================================
        // SECTION: SHARED NAME ENTRY UTILITIES
        // =================================================================================
        /**
         * Determine the next sequential default name for a given prefix.
         * @param {string} prefix
         * @param {string[]} existingNames
         */
        function getNextSequentialName(prefix, existingNames = []) {
            let highest = 0;
            const pattern = new RegExp(`^${prefix}\\s*(\\d+)$`, 'i');
            for (const rawName of existingNames) {
                if (typeof rawName !== 'string') continue;
                const match = rawName.trim().match(pattern);
                if (!match) continue;
                const parsed = parseInt(match[1], 10);
                if (!Number.isNaN(parsed) && parsed > highest) highest = parsed;
            }
            return `${prefix} ${highest + 1}`;
        }

        /**
         * Display the shared naming modal, enforcing non-empty submissions.
         * @param {{
         *   title?: string,
         *   defaultValue?: string,
         *   confirmLabel?: string,
         *   onConfirm?: (value: string) => void,
         *   onCancel?: () => void
         * }} options
         */
        function openNamePrompt(options = {}) {
            const { title = 'Name Item', defaultValue = '', confirmLabel = 'Save', onConfirm, onCancel } = options;
            activeNamePrompt = { onConfirm, onCancel };
            namePromptTitle.textContent = title;
            namePromptInput.value = typeof defaultValue === 'string' ? defaultValue : '';
            namePromptInput.classList.remove('input-error');
            namePromptConfirmBtn.textContent = confirmLabel;
            namePromptModal.style.display = 'flex';
            wasTypingBeforePrompt = isTyping;
            isTyping = true;
            requestAnimationFrame(() => {
                namePromptInput.focus();
                namePromptInput.select();
            });
        }

        /** Hide and reset the shared naming modal. */
        function closeNamePrompt() {
            namePromptModal.style.display = 'none';
            namePromptInput.value = '';
            namePromptInput.classList.remove('input-error');
            namePromptConfirmBtn.textContent = 'Save';
            const restoreTyping = wasTypingBeforePrompt;
            wasTypingBeforePrompt = false;
            isTyping = restoreTyping;
            activeNamePrompt = null;
        }

        function handleNamePromptConfirm() {
            if (!activeNamePrompt) return;
            const value = namePromptInput.value.trim();
            if (!value) {
                namePromptInput.classList.add('input-error');
                namePromptInput.focus();
                return;
            }
            const { onConfirm } = activeNamePrompt;
            closeNamePrompt();
            if (typeof onConfirm === 'function') onConfirm(value);
        }

        function handleNamePromptCancel() {
            if (!activeNamePrompt) return;
            const { onCancel } = activeNamePrompt;
            closeNamePrompt();
            if (typeof onCancel === 'function') onCancel();
        }

        namePromptInput.addEventListener('input', () => {
            if (namePromptInput.classList.contains('input-error')) {
                namePromptInput.classList.remove('input-error');
            }
        });
        namePromptConfirmBtn.addEventListener('click', handleNamePromptConfirm);
        namePromptCancelBtn.addEventListener('click', handleNamePromptCancel);
        namePromptModal.addEventListener('click', (event) => {
            if (event.target === namePromptModal) handleNamePromptCancel();
        });
        window.addEventListener('keydown', (event) => {
            if (!activeNamePrompt) return;
            if (event.key === 'Enter') {
                event.preventDefault();
                handleNamePromptConfirm();
            } else if (event.key === 'Escape') {
                event.preventDefault();
                handleNamePromptCancel();
            }
        });

        /**
         * Rebuild the live 3D scene from persisted data. Safe to call after any mutation.
         * Keeps selections if the planet still exists.
         */
        function rebuildSceneFromData() {
            // Clear existing scene planets (but not lights, ground, etc.)
            Array.from(planets.values()).forEach(planetMesh => {
                if (planetMesh.label && planetMesh.label.element && planetMesh.label.element.parentNode) {
                    planetMesh.label.element.parentNode.removeChild(planetMesh.label.element);
                }
                scene.remove(planetMesh);
                removeDecal(planetMesh.userData.id);
            });
            planets.clear();

            // Re-create planets from sceneData
            for (const [id, data] of sceneData.entries()) {
                createPlanetFromData(data, id);
            }

            // After rebuilding, re-select planet if it still exists
            const selectedId = selectedPlanet ? selectedPlanet.userData.id : null;
            if (selectedId && planets.has(selectedId)) {
                selectedPlanet = planets.get(selectedId);
                activePlanetUI = selectedPlanet.label;
                activePlanetUI.element.style.display = 'block';
            } else {
                selectedPlanet = null;
                activePlanetUI = null;
            }

            // Rebind open editors to refreshed meshes or close if planet disappeared
            for (const editorState of Array.from(openEditors.values())) {
                const refreshedPlanet = planets.get(editorState.planetId);
                if (refreshedPlanet) {
                    editorState.planet = refreshedPlanet;
                    syncEditorContent(editorState);
                } else {
                    destroyEditor(editorState, { skipAnimation: true });
                }
            }

            if (pendingNoteOpen) {
                const { planetId, noteIndex, intersection } = pendingNoteOpen;
                const targetPlanet = planets.get(planetId);
                if (targetPlanet) {
                    openNoteEditor(targetPlanet, noteIndex, { intersection });
                }
                pendingNoteOpen = null;
            }
        }


        /** Return geometry for a given shape name. */
        function getGeometry(shape) {
            switch(shape) {
                case "Sphere": return new THREE.SphereGeometry(1, 32, 32);
                case "Cone": return new THREE.ConeGeometry(1, 2, 32);
                case "Torus": return new THREE.TorusGeometry(1, 0.4, 16, 100);
                case "Box": default: return new THREE.BoxGeometry(1.5, 1.5, 1.5);
            }
        }

        /**
         * Initialize Three.js scene, UI event handlers, post-processing, and restore state.
         */
        function init() {
            // Load settings first
            loadSettings();
            moveSpeed = getSetting('movement.moveSpeed', 0.1);
            DAMPING = getSetting('movement.damping', 0.93);

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000005);
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(5, 5, 10);
            clock = new THREE.Clock();
            
            // Sticky note decal texture (subtle card look, fits analog/CRT aesthetic)
            const decalCanvas = document.createElement('canvas'); decalCanvas.width = 128; decalCanvas.height = 128; const ctx = decalCanvas.getContext('2d'); ctx.fillStyle = '#f9e79f'; ctx.fillRect(0, 0, 128, 128); ctx.fillStyle = '#f4d03f'; ctx.fillRect(0, 0, 128, 15); ctx.fillStyle = 'rgba(0,0,0,0.1)'; ctx.fillRect(120, 0, 8, 128); ctx.fillRect(0, 120, 128, 8); const decalTexture = new THREE.CanvasTexture(decalCanvas);
            decalMaterial = new THREE.MeshStandardMaterial({ map: decalTexture, polygonOffset: true, polygonOffsetFactor: -4, transparent: true, opacity: 0.9 });

            // Procedural star field for deep-space ambiance
            const starsGeometry = new THREE.BufferGeometry(); const starsVertices = []; for (let i = 0; i < 20000; i++) { starsVertices.push(THREE.MathUtils.randFloatSpread(2000)); starsVertices.push(THREE.MathUtils.randFloatSpread(2000)); starsVertices.push(THREE.MathUtils.randFloatSpread(2000)); } starsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starsVertices, 3)); const starsMaterial = new THREE.PointsMaterial({ color: 0xffffff, size: 0.15, transparent: true, blending: THREE.AdditiveBlending }); scene.add(new THREE.Points(starsGeometry, starsMaterial));

            // Core renderers
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true }); renderer.setSize(window.innerWidth, window.innerHeight); renderer.setPixelRatio(window.devicePixelRatio); renderer.shadowMap.enabled = true; sceneContainer.appendChild(renderer.domElement);
            labelRenderer = new THREE.CSS2DRenderer(); labelRenderer.setSize(window.innerWidth, window.innerHeight); labelRenderer.domElement.style.position = 'absolute'; labelRenderer.domElement.style.top = '0px'; labelRenderer.domElement.style.pointerEvents = 'none'; sceneContainer.appendChild(labelRenderer.domElement);

            // Lighting + subtle ground plane reference
            scene.add(new THREE.AmbientLight(0xffffff, 0.6)); const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8); directionalLight.position.set(10, 20, 5); directionalLight.castShadow = true; scene.add(directionalLight);
            const plane = new THREE.Mesh( new THREE.PlaneGeometry(100, 100), new THREE.MeshStandardMaterial({ color: 0xcccccc, roughness: 0.8, metalness: 0.1, transparent: true, opacity: 0.25 }) ); plane.rotation.x = -Math.PI / 2; plane.receiveShadow = true; scene.add(plane);

            // Orbit controls: rotation via mouse-drag; keyboard handled manually for custom momentum
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            Object.assign(controls, {
                enableDamping: getSetting('controls.enableDamping', true),
                dampingFactor: getSetting('controls.dampingFactor', 0.05),
                minDistance: getSetting('controls.minDistance', 3),
                maxDistance: getSetting('controls.maxDistance', 50),
                maxPolarAngle: getSetting('controls.maxPolarAngle', Math.PI / 2.1),
                enableKeys: false
            });
            controls.addEventListener('start', () => { isDraggingCamera = true; });
            controls.addEventListener('end', () => { setTimeout(() => { isDraggingCamera = false; }, 0); });
            raycaster = new THREE.Raycaster(); mouse = new THREE.Vector2();

            // Post-processing: subtle RGB offset + film scanlines (CRT flavor)
            composer = new THREE.EffectComposer(renderer);
            composer.addPass(new THREE.RenderPass(scene, camera));
            const RetroShader = {
                uniforms: { 'tDiffuse': { value: null }, 'rgbOffset': { value: getSetting('post.rgbOffset', 0.0015) }, 'vigStart': { value: getSetting('post.vignetteStart', 0.4) }, 'vigEnd': { value: getSetting('post.vignetteEnd', 0.9) } },
                vertexShader: `varying vec2 vUv; void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 ); }`,
                fragmentShader: `uniform sampler2D tDiffuse; uniform float rgbOffset; uniform float vigStart; uniform float vigEnd; varying vec2 vUv; void main() { vec2 offset = vec2(rgbOffset, rgbOffset); vec4 cr = texture2D(tDiffuse, vUv + offset); vec4 cg = texture2D(tDiffuse, vUv); vec4 cb = texture2D(tDiffuse, vUv - offset); gl_FragColor = vec4(cr.r, cg.g, cb.b, cg.a); float vignette = 1.0 - smoothstep(vigStart, vigEnd, distance(vUv, vec2(0.5))); gl_FragColor.rgb *= vignette; }`
            };
            const retroPass = new THREE.ShaderPass(RetroShader);
            composer.addPass(retroPass);
            filmPass = new THREE.FilmPass(
                getSetting('post.filmNoise', 0.3),
                getSetting('post.filmScanlineIntensity', 0.2),
                getSetting('post.filmScanlineCount', 1024),
                getSetting('post.filmGrayscale', false)
            );
            composer.addPass(filmPass);

            // Events: keep concise; prevent Tab from moving focus when cycling planets
            window.addEventListener('resize', onWindowResize);
            window.addEventListener('keydown', (event) => {
                if (activeNamePrompt) {
                    if (event.key === 'Tab') event.preventDefault();
                    return;
                }
                if (event.key === 'Tab') {
                    event.preventDefault();
                    if (!isTyping) cycleToPlanet();
                } else {
                    keyState[event.code] = true;
                }
            });
            window.addEventListener('keyup', (event) => { keyState[event.code] = false; });
            sceneContainer.addEventListener('mousedown', (e) => { sceneContainer.focus(); });
            sceneContainer.addEventListener('click', onPlanetClick);

            // Primary UI actions
            addPlanetBtn.addEventListener('click', handleCreatePlanetClick);
            modalConfirmBtn.addEventListener('click', () => { if (deleteAction) deleteAction(); });
            modalCancelBtn.addEventListener('click', hideModal);
            savePlanetBtn.addEventListener('click', savePlanetChanges);
            closePlanetEditBtn.addEventListener('click', closePlanetEditPanel);
            planetCloseBtn.addEventListener('click', closePlanetEditPanel);
            deletePlanetBtn.addEventListener('click', handleDeletePlanetFromEditor);

            loadDataFromStorage();
            rebuildSceneFromData();
            animate();
        }

        /** Make an element draggable using a handle element. */
        function initDrag(element, handle) { let startX, startY, startLeft, startTop; function doDrag(e) { e.preventDefault(); element.style.right = "auto"; element.style.left = (startLeft + e.clientX - startX) + 'px'; element.style.top = (startTop + e.clientY - startY) + 'px'; } function stopDrag() { document.documentElement.removeEventListener('mousemove', doDrag, false); document.documentElement.removeEventListener('mouseup', stopDrag, false); } handle.addEventListener('mousedown', (e) => { e.preventDefault(); e.stopPropagation(); startX = e.clientX; startY = e.clientY; const rect = element.getBoundingClientRect(); startLeft = rect.left; startTop = rect.top; document.documentElement.addEventListener('mousemove', doDrag, false); document.documentElement.addEventListener('mouseup', stopDrag, false); }, false); }
        /** Resize from bottom-left handle. Keeps right edge fixed by switching to left positioning. */
        function initResizeBL(element, handle) { let startX, startY, startWidth, startHeight, startLeft; function doDrag(e) { e.preventDefault(); element.style.right = 'auto'; element.style.width = (startWidth - (e.clientX - startX)) + 'px'; element.style.height = (startHeight + (e.clientY - startY)) + 'px'; element.style.left = (startLeft + (e.clientX - startX)) + 'px'; } function stopDrag() { document.documentElement.removeEventListener('mousemove', doDrag, false); document.documentElement.removeEventListener('mouseup', stopDrag, false); } handle.addEventListener('mousedown', (e) => { e.preventDefault(); e.stopPropagation(); startX = e.clientX; startY = e.clientY; const rect = element.getBoundingClientRect(); startWidth = rect.width; startHeight = rect.height; startLeft = rect.left; document.documentElement.addEventListener('mousemove', doDrag, false); document.documentElement.addEventListener('mouseup', stopDrag, false); }, false); }
        /** Resize from bottom-right handle. */
        function initResizeBR(element, handle) { let startX, startY, startWidth, startHeight; function doDrag(e) { e.preventDefault(); element.style.width = (startWidth + (e.clientX - startX)) + 'px'; element.style.height = (startHeight + (e.clientY - startY)) + 'px'; } function stopDrag() { document.documentElement.removeEventListener('mousemove', doDrag, false); document.documentElement.removeEventListener('mouseup', stopDrag, false); } handle.addEventListener('mousedown', (e) => { e.preventDefault(); e.stopPropagation(); startX = e.clientX; startY = e.clientY; const rect = element.getBoundingClientRect(); startWidth = rect.width; startHeight = rect.height; element.style.left = rect.left + 'px'; element.style.right = 'auto'; document.documentElement.addEventListener('mousemove', doDrag, false); document.documentElement.addEventListener('mouseup', stopDrag, false); }, false); }
        
        /** Open planet editor for new planet creation. */
        function handleCreatePlanetClick() { showPlanetEditPanel(); }
        
        function getEditorKey(planetId, noteIndex) {
            return `${planetId}:${noteIndex}`;
        }

        function captureIntersectionSnapshot(intersection) {
            if (!intersection) return null;
            return {
                point: intersection.point.clone(),
                normal: intersection.face && intersection.face.normal ? intersection.face.normal.clone() : null,
            };
        }

        function focusEditor(editorState) {
            if (!editorState || !editorState.element) return;
            editorState.element.style.zIndex = `${++nextEditorZ}`;
            if (editorState.connector) {
                if (!editorState.connector.isConnected) {
                    editorsRoot.appendChild(editorState.connector);
                }
                editorState.connector.style.zIndex = `${nextEditorZ - 1}`;
            }
        }

        function getExistingEditorRects(excludeElement) {
            return Array.from(openEditors.values())
                .filter(state => state.element && state.element !== excludeElement)
                .map(state => state.element.getBoundingClientRect());
        }

        function findEditorSpawnPosition(element) {
            if (!element) {
                return { top: 20, left: Math.max(20, window.innerWidth - 320) };
            }

            const margin = 20;
            const rect = element.getBoundingClientRect();
            const width = rect.width || element.offsetWidth || 300;
            const height = rect.height || element.offsetHeight || 260;
            const minLeft = margin;
            const maxLeft = Math.max(minLeft, window.innerWidth - width - margin);
            const maxTop = Math.max(margin, window.innerHeight - height - margin);
            const preferredLeft = maxLeft;
            const preferredTop = margin;
            const verticalStep = Math.max(40, Math.round(height * 0.25));
            const horizontalStep = Math.max(40, Math.round(width * 0.25));
            const maxRows = Math.max(1, Math.floor((maxTop - margin) / verticalStep) + 1);
            const maxCols = Math.max(1, Math.floor((maxLeft - minLeft) / horizontalStep) + 1);
            const existingRects = getExistingEditorRects(element);

            const collides = (top, left) => {
                const right = left + width;
                const bottom = top + height;
                return existingRects.some(r => !(right <= r.left || left >= r.right || bottom <= r.top || top >= r.bottom));
            };

            const candidates = [];
            for (let diag = 0; diag < maxRows + maxCols; diag++) {
                for (let row = 0; row <= diag; row++) {
                    const col = diag - row;
                    if (row >= maxRows || col >= maxCols) continue;
                    const top = margin + row * verticalStep;
                    const left = preferredLeft - col * horizontalStep;
                    if (top > maxTop || left < minLeft) continue;
                    candidates.push({ top, left });
                }
            }

            candidates.push({
                top: Math.min(preferredTop, maxTop),
                left: Math.min(Math.max(minLeft, preferredLeft), maxLeft),
            });

            for (const candidate of candidates) {
                if (!collides(candidate.top, candidate.left)) {
                    return candidate;
                }
            }

            return {
                top: Math.min(preferredTop, maxTop),
                left: Math.min(Math.max(minLeft, preferredLeft), maxLeft),
            };
        }

        function positionEditor(editorState) {
            if (!editorState || !editorState.element) return;
            const { element } = editorState;
            element.style.right = 'auto';
            const { top, left } = findEditorSpawnPosition(element);
            element.style.top = `${top}px`;
            element.style.left = `${left}px`;
        }

        function attachEditorEvents(editorState) {
            const { element, dragHandle, resizeBL, resizeBR, titleInput, contentInput, saveBtn, deleteBtn, closeBtn } = editorState;
            if (dragHandle) initDrag(element, dragHandle);
            if (resizeBL) initResizeBL(element, resizeBL);
            if (resizeBR) initResizeBR(element, resizeBR);

            element.addEventListener('mousedown', () => focusEditor(editorState));
            element.addEventListener('focusin', () => focusEditor(editorState));

            const markTyping = () => { isTyping = true; };
            const clearTyping = () => { isTyping = false; };
            titleInput.addEventListener('focus', markTyping);
            titleInput.addEventListener('blur', clearTyping);
            contentInput.addEventListener('focus', markTyping);
            contentInput.addEventListener('blur', clearTyping);

            saveBtn.addEventListener('click', () => saveNote(editorState));
            deleteBtn.addEventListener('click', () => handleDeleteNoteClick(editorState));
            closeBtn.addEventListener('click', () => closeNoteEditorWithAnimation(editorState));
        }

        function getNoteData(planetId, noteIndex) {
            const planetData = sceneData.get(planetId);
            if (!planetData || !Array.isArray(planetData.notes)) {
                return { title: '', content: '' };
            }
            const note = planetData.notes[noteIndex];
            return note ? { title: note.title || '', content: note.content || '' } : { title: '', content: '' };
        }

        function syncEditorContent(editorState) {
            if (!editorState) return;
            const { planetId, noteIndex, titleInput, contentInput } = editorState;
            const note = getNoteData(planetId, noteIndex);
            if (titleInput && document.activeElement !== titleInput) {
                titleInput.value = note.title;
            }
            if (contentInput && document.activeElement !== contentInput) {
                contentInput.value = note.content;
            }
        }

        function instantiateEditor(planet, noteIndex, options = {}) {
            const planetId = planet.userData.id;
            const key = getEditorKey(planetId, noteIndex);
            if (openEditors.has(key)) {
                const existing = openEditors.get(key);
            const templateRoot = noteEditorTemplate.content.firstElementChild;
            if (!templateRoot) throw new Error('Note editor template with class "note-editor" is missing in #note-editor-template. Please ensure the template exists and has a root element with the correct structure.');
                return existing;
            }

            const templateRoot = noteEditorTemplate.content.firstElementChild;
            if (!templateRoot) throw new Error('Note editor template is missing root element.');
            const editorElement = templateRoot.cloneNode(true);
            editorElement.style.display = 'flex';
            editorElement.dataset.editorKey = key;
            editorElement.style.zIndex = `${++nextEditorZ}`;
            editorElement.style.visibility = 'hidden';
            editorElement.style.left = 'auto';

            const titleInput = editorElement.querySelector('.note-title');
            const contentInput = editorElement.querySelector('.note-content');
            const saveBtn = editorElement.querySelector('.note-save-btn');
            const deleteBtn = editorElement.querySelector('.note-delete-btn');
            const closeBtn = editorElement.querySelector('.note-close-btn');
            const dragHandle = editorElement.querySelector('.drag-handle');
            const resizeBL = editorElement.querySelector('.resize-handle-bl');
            const resizeBR = editorElement.querySelector('.resize-handle-br');
            const connector = document.createElement('div');
            connector.className = 'note-connector';
            editorsRoot.appendChild(connector);

            const editorState = {
                key,
                planetId,
                planet,
                noteIndex,
                element: editorElement,
                titleInput,
                contentInput,
                saveBtn,
                deleteBtn,
                closeBtn,
                dragHandle,
                resizeBL,
                resizeBR,
                connector,
                intersection: options.intersection || null,
            };

            attachEditorEvents(editorState);
            editorsRoot.appendChild(editorElement);
            positionEditor(editorState);
            editorElement.style.visibility = 'visible';
            openEditors.set(key, editorState);
            syncEditorContent(editorState);
            focusEditor(editorState);
            return editorState;
        }

        function destroyEditor(editorState, { skipAnimation = false } = {}) {
            if (!editorState) return;
            const { element, key, connector } = editorState;
            if (!element) return;
            if (!skipAnimation && element.classList.contains('closing')) return;

            if (document.activeElement === editorState.titleInput || document.activeElement === editorState.contentInput) {
                isTyping = false;
            }

            if (openEditors.has(key)) openEditors.delete(key);
            if (element.parentNode) element.parentNode.removeChild(element);
            if (connector && connector.parentNode) connector.parentNode.removeChild(connector);
        }

        function closeNoteEditorWithAnimation(editorState) {
            if (!editorState || !editorState.element) return;
            const { element } = editorState;
            if (element.classList.contains('closing')) return;
            if (editorState.connector) editorState.connector.style.display = 'none';
            element.classList.add('closing');
            element.addEventListener('animationend', () => {
                element.classList.remove('closing');
                destroyEditor(editorState, { skipAnimation: true });
            }, { once: true });
        }

        function saveNote(editorState) {
            if (!editorState || !editorState.planet) return;
            const { planet, planetId, noteIndex, titleInput, contentInput, intersection } = editorState;
            const planetData = sceneData.get(planetId);
            if (!planetData) return;

            const notes = Array.isArray(planetData.notes) ? [...planetData.notes] : [];
            notes[noteIndex] = { title: titleInput.value, content: contentInput.value };

            const hasAnyNoteContent = notes.some(note => note && (note.title || note.content));

            if (hasAnyNoteContent && !planetData.decal && intersection && planet) {
                const orientation = new THREE.Euler();
                const faceNormal = intersection.normal ? intersection.normal.clone() : planet.up.clone();
                const matrix = new THREE.Matrix4().lookAt(
                    intersection.point,
                    intersection.point.clone().sub(faceNormal),
                    planet.up
                );
                orientation.setFromRotationMatrix(matrix);
                const inverseMatrix = new THREE.Matrix4().copy(planet.matrixWorld).invert();
                planetData.decal = {
                    position: intersection.point.clone().applyMatrix4(inverseMatrix),
                    orientation: { x: orientation.x, y: orientation.y, z: orientation.z },
                };
            } else if (!hasAnyNoteContent) {
                planetData.decal = null;
            }

            planetData.notes = notes;
            sceneData.set(planetId, planetData);
            saveDataToStorage();
            rebuildSceneFromData();
            closeNoteEditorWithAnimation(editorState);
        }

        function handleDeleteNoteClick(editorState) {
            if (!editorState) return;
            const { planetId, noteIndex } = editorState;
            const planetData = sceneData.get(planetId);
            if (!planetData) return;

            confirmMessage.textContent = 'Delete this note?';
            confirmModal.style.display = 'flex';
            deleteAction = () => {
                const notes = Array.isArray(planetData.notes) ? [...planetData.notes] : [];
                notes.splice(noteIndex, 1);
                planetData.notes = notes;
                const hasAnyNoteContent = notes.some(n => (n && (n.title || n.content)));
                if (!hasAnyNoteContent) planetData.decal = null;
                sceneData.set(planetId, planetData);
                saveDataToStorage();
                rebuildSceneFromData();
                for (const otherEditor of Array.from(openEditors.values())) {
                    if (otherEditor.planetId === planetId && otherEditor.key !== editorState.key) {
                        closeNoteEditorWithAnimation(otherEditor);
                    }
                }
                closeNoteEditorWithAnimation(editorState);
                hideModal();
            };
        }

        function openNoteEditor(planet, index, options = {}) {
            const intersection = options.intersection || captureIntersectionSnapshot(lastIntersection);
            instantiateEditor(planet, index, { intersection });
        }
        
        /** Save planet property edits or create a new planet. */
        function savePlanetChanges() {
            const newName = planetNameInput.value.trim();
            if (!newName) {
                planetNameInput.classList.add('input-error');
                planetNameInput.focus();
                return;
            }

            const newShape = shapeTypeSelect.value;
            const newColor = planetColorInput.value;

            if (editingPlanet) {
                const planetId = editingPlanet.userData.id;
                const planetData = sceneData.get(planetId);
                if (planetData) {
                    planetData.name = newName;
                    planetData.shape = newShape;
                    planetData.color = newColor;
                    sceneData.set(planetId, planetData);
                }
            } else {
                const newId = crypto.randomUUID();
                sceneData.set(newId, {
                    name: newName,
                    shape: newShape,
                    color: newColor,
                    position: {
                        x: (Math.random() - 0.5) * 20,
                        y: Math.random() * 2 + 1,
                        z: (Math.random() - 0.5) * 20,
                    },
                    notes: [],
                    decal: null,
                });
            }

            saveDataToStorage();
            rebuildSceneFromData();
            closePlanetEditPanel();
        }

        /** Confirm delete planet flow from the planet editor. */
        function handleDeletePlanetFromEditor() {
            if (!editingPlanet) return;
            confirmMessage.textContent = 'Delete this planet and all of its notes?';
            confirmModal.style.display = 'flex';
            deleteAction = () => {
                fadeAndDeletePlanet(editingPlanet);
                hideModal();
                closePlanetEditPanel();
                if (activePlanetUI) activePlanetUI.element.style.display = 'none';
                activePlanetUI = null;
            };
        }

        /** Smoothly fade a planet and its decal, then remove from scene and storage. */
        function fadeAndDeletePlanet(planetToDelete) {
            const planetId = planetToDelete.userData.id;
            const duration = 500;
            const startTime = performance.now();

            // Close any open note tied to this planet (before it disappears)
            for (const editorState of Array.from(openEditors.values())) {
                if (editorState.planetId === planetId) {
                    closeNoteEditorWithAnimation(editorState);
                }
            }
            lastIntersection = null;
            if (pendingNoteOpen && pendingNoteOpen.planetId === planetId) {
                pendingNoteOpen = null;
            }

            planetToDelete.traverse((child) => {
                if (child.isMesh) {
                    child.material = child.material.clone();
                    child.material.transparent = true;
                }
            });
            const decal = decals.get(planetId);
            if (decal) decal.material.transparent = true;

            function fade() {
                const progress = Math.min((performance.now() - startTime) / duration, 1);
                const opacity = 1 - progress;
                planetToDelete.traverse((child) => { if (child.isMesh) child.material.opacity = opacity; });
                if (decal) decal.material.opacity = opacity;
                if (progress < 1) requestAnimationFrame(fade);
                else {
                    sceneData.delete(planetId);
                    saveDataToStorage();
                    rebuildSceneFromData();
                }
            }

            requestAnimationFrame(fade);
        }
        function hideModal() { confirmModal.style.display = 'none'; deleteAction = null; }
        
        /** Remove previously placed decal for a planet (if any). */
        function removeDecal(planetId) {
            if (decals.has(planetId)) {
                const decal = decals.get(planetId);
                scene.remove(decal);
                decal.geometry.dispose();
                decals.delete(planetId);
            }
        }
        /** Place or update a sticky-note style DecalGeometry on the planet using saved local transform. */
        function placeOrUpdateDecal(planetId, data) {
            removeDecal(planetId);
            const parentPlanet = planets.get(planetId);
            if (!parentPlanet || !data.decal) return;
            const position = new THREE.Vector3().copy(data.decal.position).applyMatrix4(parentPlanet.matrixWorld);
            const orientation = new THREE.Euler().copy(data.decal.orientation);
            const s = getSetting('notes.decalSize', 0.75);
            const decalGeom = new THREE.DecalGeometry(parentPlanet, position, orientation, new THREE.Vector3(s, s, s));
            const decal = new THREE.Mesh(decalGeom, decalMaterial);
            decal.material = decal.material.clone();
            decal.material.opacity = getSetting('notes.decalOpacity', 0.9);
            decal.material.transparent = true;
            decals.set(planetId, decal);
            scene.add(decal);
        }
        
        /** Construct a THREE.Mesh from PlanetData and attach an on-planet UI label. */
        function createPlanetFromData(data, id) {
            const geometry = getGeometry(data.shape);
            const material = new THREE.MeshStandardMaterial({
                color: data.color || "#ffffff",
                roughness: 0.5,
                metalness: 0.1
            });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(data.position.x, data.position.y, data.position.z);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            mesh.userData = { id, data };

            const planetDiv = document.createElement('div');
            planetDiv.className = 'planet-ui';

            const header = document.createElement('div');
            header.className = 'planet-ui-header';

            const title = document.createElement('h3');
            title.textContent = data.name;

            const editBtn = document.createElement('button');
            editBtn.className = 'edit-planet-btn';
            editBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M12.854.146a.5.5 0 0 0-.707 0L10.5 1.793 14.207 5.5l1.647-1.646a.5.5 0 0 0 0-.708l-3-3zm.646 6.061L9.793 2.5 3.293 9H3.5a.5.5 0 0 1 .5.5v.5h.5a.5.5 0 0 1 .5.5v.5h.5a.5.5 0 0 1 .5.5v.5h.5a.5.5 0 0 1 .5.5v.207l6.5-6.5zm-7.468 7.468A.5.5 0 0 1 6 13.5V13h-.5a.5.5 0 0 1-.5-.5V12h-.5a.5.5 0 0 1-.5-.5V11h-.5a.5.5 0 0 1-.5-.5V10h-.5a.499.499 0 0 1-.175-.032l-.179.178a.5.5 0 0 0-.11.168l-2 5a.5.5 0 0 0 .65.65l5-2a.5.5 0 0 0 .168-.11l.178-.178z"/></svg>`;
            editBtn.onclick = (e) => {
                e.stopPropagation();
                showPlanetEditPanel(mesh);
            };

            header.appendChild(title);
            header.appendChild(editBtn);

            const notesList = document.createElement('ul');
            notesList.className = 'notes-list';
            (data.notes || []).forEach((note, index) => {
                const li = document.createElement('li');
                li.textContent = note.title || `Note ${index + 1}`;
                li.onclick = (e) => {
                    e.stopPropagation();
                    openNoteEditor(mesh, index);
                };
                notesList.appendChild(li);
            });

            const addNoteBtn = document.createElement('button');
            addNoteBtn.className = 'add-note-btn';
            addNoteBtn.textContent = '+ New Note';
            addNoteBtn.onclick = (e) => {
                e.stopPropagation();
                addNewNote(mesh);
            };

            planetDiv.appendChild(header);
            planetDiv.appendChild(notesList);
            planetDiv.appendChild(addNoteBtn);

            const planetLabel = new THREE.CSS2DObject(planetDiv);
            planetLabel.position.set(0, 1.5, 0);
            mesh.add(planetLabel);
            mesh.label = planetLabel;
            planetLabel.element.style.display = 'none';

            scene.add(mesh);
            planets.set(id, mesh);
            placeOrUpdateDecal(id, data);
        }
        /** Populate and show the planet edit panel (or defaults for a new planet). */
        function showPlanetEditPanel(planet = null) {
            editingPlanet = planet;
            planetNameInput.classList.remove('input-error');

            if (editingPlanet) {
                const data = editingPlanet.userData.data;
                planetNameInput.value = data.name;
                shapeTypeSelect.value = data.shape;
                planetColorInput.value = data.color;
            } else {
                const existingNames = Array.from(sceneData.values()).map(entry => (entry && entry.name) ? entry.name : '');
                planetNameInput.value = getNextSequentialName('Planet', existingNames);
                shapeTypeSelect.value = 'Box';
                planetColorInput.value = '#' + Math.floor(Math.random() * 16777215).toString(16).padStart(6, '0');
            }

            planetEditPanel.style.display = 'flex';
            wasTypingBeforePlanetEdit = isTyping;
            isTyping = true;

            requestAnimationFrame(() => {
                planetNameInput.focus();
                if (!editingPlanet) {
                    planetNameInput.select();
                }
            });
        }

        /** Hide the planet edit panel and reset state. */
        function closePlanetEditPanel() {
            planetEditPanel.style.display = 'none';
            editingPlanet = null;
            planetNameInput.classList.remove('input-error');
            isTyping = wasTypingBeforePlanetEdit;
            wasTypingBeforePlanetEdit = false;
        }

        /** Create and select a new empty note for a planet, auto-numbered. */
        function addNewNote(planet) {
            const planetId = planet.userData.id;
            const planetData = sceneData.get(planetId);
            if (!planetData) return;

            const notes = Array.isArray(planetData.notes) ? [...planetData.notes] : [];
            const existingNames = notes.map(note => (note && note.title) ? note.title : '');
            const suggestedTitle = getNextSequentialName('Note', existingNames);

            openNamePrompt({
                title: 'Name your note',
                defaultValue: suggestedTitle,
                confirmLabel: 'Create Note',
                onConfirm: (noteTitle) => {
                    const updatedNotes = [...notes, { title: noteTitle, content: '' }];
                    planetData.notes = updatedNotes;
                    sceneData.set(planetId, planetData);
                    saveDataToStorage();
                    rebuildSceneFromData();
                    pendingNoteOpen = { planetId, noteIndex: updatedNotes.length - 1, intersection: captureIntersectionSnapshot(lastIntersection) };
                },
            });
        }

        /**
         * Keyboard movement with simple momentum. Disabled while typing to avoid accidental motion.
         */
        function handleCameraMovement() { const moveDirection = new THREE.Vector3(); if (!isTyping) { const forward = new THREE.Vector3(); camera.getWorldDirection(forward); const right = new THREE.Vector3().crossVectors(forward, camera.up); if (keyState['KeyW'] || keyState['ArrowUp']) moveDirection.add(forward); if (keyState['KeyS'] || keyState['ArrowDown']) moveDirection.sub(forward); if (keyState['KeyA'] || keyState['ArrowLeft']) moveDirection.sub(right); if (keyState['KeyD'] || keyState['ArrowRight']) moveDirection.add(right); if (keyState['KeyE']) moveDirection.y += 1; if (keyState['KeyQ']) moveDirection.y -= 1; } if (moveDirection.lengthSq() > 0) cameraVelocity.copy(moveDirection.normalize().multiplyScalar(moveSpeed)); camera.position.add(cameraVelocity); controls.target.add(cameraVelocity); cameraVelocity.multiplyScalar(DAMPING); }
        
        /**
         * Raycast click on planets to toggle their on-planet UI.
         * Ignores clicks that originate from UI elements or while dragging the camera.
         */
        function onPlanetClick(event) {
            if (isDraggingCamera) return;
            const uiElements = document.querySelectorAll('.planet-ui, .note-editor, #planet-edit-panel, #add-planet-btn, #confirm-modal, #name-prompt-modal');
            for (const el of uiElements) {
                if (el.contains(event.target)) return;
            }
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(Array.from(planets.values()), true);

            if (intersects.length > 0) {
                lastIntersection = intersects[0];
                let clickedPlanet = lastIntersection.object;
                while (clickedPlanet.parent && !clickedPlanet.userData.id) {
                    clickedPlanet = clickedPlanet.parent;
                }
                if (clickedPlanet.userData.id && planets.has(clickedPlanet.userData.id)) {
                    if (selectedPlanet && selectedPlanet.userData.id === clickedPlanet.userData.id) return;
                    if (activePlanetUI) activePlanetUI.element.style.display = 'none';
                    selectedPlanet = planets.get(clickedPlanet.userData.id);
                    activePlanetUI = selectedPlanet.label;
                    activePlanetUI.element.style.display = 'block';
                }
            } else {
                if (activePlanetUI) {
                    activePlanetUI.element.style.display = 'none';
                    activePlanetUI = null;
                }
                selectedPlanet = null;
                lastIntersection = null;
            }
        }

        /** Hide on-planet UI when moving too far from the selection to reduce clutter. */
        function checkPlanetUIDistance() {
            if (activePlanetUI && selectedPlanet) {
                const distance = camera.position.distanceTo(selectedPlanet.position);
                const cutoff = getSetting('ui.labelHideDistance', 20);
                if (distance > cutoff) {
                    activePlanetUI.element.style.display = 'none';
                    activePlanetUI = null;
                    selectedPlanet = null;
                }
            }
        }
        /** Easing helpers (comfort-first). */
        function easeInOutCubic(t) { return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2; }
        function easeOutCubic(t) { return 1 - Math.pow(1 - t, 3); }
        function easeInOutQuad(t) { return t < 0.5 ? 2*t*t : 1 - Math.pow(-2*t + 2, 2)/2; }
        function resolveEasing(name) {
            switch (name) {
                case 'easeOutCubic': return easeOutCubic;
                case 'easeInOutQuad': return easeInOutQuad;
                case 'easeInOutCubic':
                default: return easeInOutCubic;
            }
        }
        /** Smooth camera tween to cycle through planets on Tab. */
        function cycleToPlanet() {
            const planetArray = Array.from(planets.values());
            if (planetArray.length === 0) return;
            // If a cycle is already in progress, cancel it and start a new one from the current pose
            if (isCycling) isCycling = false;
            isCycling = true;
            cycleIndex = (cycleIndex + 1) % planetArray.length;

            const targetPlanet = planetArray[cycleIndex];
            const targetPosition = targetPlanet.position.clone();

            // Maintain viewing direction relative to target: keep about 10 units away from the planet.
            const direction = new THREE.Vector3().subVectors(camera.position, targetPosition).normalize();
            const lockDistance = getSetting('cycle.distance', 10);
            const newCameraPosition = new THREE.Vector3().addVectors(targetPosition, direction.multiplyScalar(lockDistance));

            const duration = getSetting('cycle.durationMs', 350); // ms – quick, comfortable lock-on
            const startPos = camera.position.clone();
            const startTarget = controls.target.clone();
            const startTime = performance.now();
            const easingFn = resolveEasing(getSetting('cycle.easing', 'easeInOutCubic'));

            // Prepare selection/UI immediately so the user perceives focus change
            if (activePlanetUI) activePlanetUI.element.style.display = 'none';
            selectedPlanet = targetPlanet;
            activePlanetUI = selectedPlanet.label;
            if (activePlanetUI) activePlanetUI.element.style.display = 'block';

            function step(now) {
                if (!isCycling) return;
                const t = Math.min(1, (now - startTime) / duration);
                const e = easingFn(t);
                camera.position.lerpVectors(startPos, newCameraPosition, e);
                controls.target.lerpVectors(startTarget, targetPosition, e);
                controls.update();
                if (t < 1) requestAnimationFrame(step);
                else {
                    // Snap to exact final state and zero momentum so we don't drift
                    camera.position.copy(newCameraPosition);
                    controls.target.copy(targetPosition);
                    cameraVelocity.set(0, 0, 0);
                    controls.update();
                    isCycling = false;
                }
            }
            requestAnimationFrame(step);
        }
        /** Keep composer sizes in sync with viewport. */
        function onWindowResize() { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); labelRenderer.setSize(window.innerWidth, window.innerHeight); composer.setSize(window.innerWidth, window.innerHeight); }
        
        /**
         * Draw a line from the editor panel to the planet's screen position to support spatial association.
         */
        function updateLineConnectors() {
            const show = getSetting('ui.showConnector', true);
            for (const editorState of openEditors.values()) {
                const { element, planet, connector } = editorState;
                if (!connector) continue;

                if (!show || !planet || !element || element.style.display === 'none' || element.classList.contains('closing')) {
                    connector.style.display = 'none';
                    continue;
                }

                const projected = planet.position.clone().project(camera);
                if (projected.z < -1 || projected.z > 1) {
                    connector.style.display = 'none';
                    continue;
                }
                const screenX = (projected.x * 0.5 + 0.5) * window.innerWidth;
                const screenY = (-projected.y * 0.5 + 0.5) * window.innerHeight;
                const uiRect = element.getBoundingClientRect();
                const uiX = uiRect.left + uiRect.width / 2;
                const uiY = uiRect.top + uiRect.height / 2;
                const dx = screenX - uiX;
                const dy = screenY - uiY;
                const length = Math.hypot(dx, dy);
                const angle = Math.atan2(dy, dx) * (180 / Math.PI);
                connector.style.left = `${uiX}px`;
                connector.style.top = `${uiY}px`;
                connector.style.width = `${length}px`;
                connector.style.transform = `rotate(${angle}deg)`;
                connector.style.display = 'block';
                connector.style.zIndex = `${Math.max(0, parseInt(element.style.zIndex || `${nextEditorZ}`, 10) - 1)}`;
            }
        }

        /** Main render loop. */
        function animate() {
            requestAnimationFrame(animate);
            if(!isCycling) handleCameraMovement();
            controls.update();
            checkPlanetUIDistance();
            updateLineConnectors();
            filmPass.uniforms.time.value = clock.getElapsedTime();
            composer.render();
            labelRenderer.render(scene, camera);
        }

        // Initial call
        init();
    </script>
</body>
</html>

