<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Note Taker</title>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            overflow: hidden;
            background-color: #000005;
            color: #333;
        }
        #scene-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            cursor: grab;
        }
        #scene-container:focus {
            outline: none; /* Removes the blue outline on focus */
        }
        #ui-container {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 300px;
            min-width: 250px; /* Minimum resize width */
            min-height: 250px; /* Minimum resize height */
            background: rgba(255, 255, 255, 0.1);
            border-radius: 0; /* Square corners */
            box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.37);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            border: 1px solid rgba(255, 255, 255, 0.5);
            padding-top: 30px; /* Make space for drag handle and close button */
            display: none;
            flex-direction: column;
            gap: 15px;
            max-height: calc(100vh - 40px);
            overflow: hidden; /* Changed from auto to hidden for resize */
            z-index: 1000;
            transform-origin: center;
        }

        /* CRT "Off" Animation */
        #ui-container.closing {
            animation: crt-flicker-out 400ms forwards;
        }

        #ui-container.closing > * {
            visibility: hidden; /* Hide content during animation */
        }

        @keyframes crt-flicker-out {
            0% { transform: scale(1, 1); background-color: rgba(255, 255, 255, 0.1); backdrop-filter: blur(8px); -webkit-backdrop-filter: blur(8px); }
            40% { transform: scale(1, 0.01); background-color: white; backdrop-filter: blur(0px); -webkit-backdrop-filter: blur(0px); }
            80% { transform: scale(0.005, 0.005); background-color: white; }
            100% { transform: scale(0, 0); background-color: white; }
        }

        #drag-handle {
            position: absolute;
            top: 0;
            left: 0;
            width: calc(100% - 30px); /* Leave space for close button */
            height: 30px;
            cursor: move;
        }

        #note-title {
            font-size: 1.2em;
            font-weight: bold;
            color: #fff;
            border: none;
            background: transparent;
            border-bottom: 2px solid rgba(255, 255, 255, 0.5);
            padding: 8px 0;
            transition: border-color 0.3s;
            flex-shrink: 0;
            margin: 0 20px; /* Add margin to align with padding */
        }
        #note-title:focus { outline: none; border-bottom-color: #fff; }
        #note-title::placeholder { color: rgba(255, 255, 255, 0.7); }

        #note-content {
            font-size: 1em;
            min-height: 150px;
            resize: none; 
            background: rgba(255, 255, 255, 0.2);
            color: #fff;
            border: 1px solid rgba(255, 255, 255, 0.5);
            border-radius: 0; /* Square corners */
            padding: 10px;
            transition: border-color 0.3s, box-shadow 0.3s;
            flex-grow: 1;
            margin: 0 20px;
        }
        #note-content:focus { outline: none; border-color: #fff; box-shadow: 0 0 5px rgba(255, 255, 255, 0.5); }
        #note-content::placeholder { color: rgba(255, 255, 255, 0.7); }
        .button-group {
            display: flex;
            justify-content: flex-end; /* Align buttons to the right */
            gap: 10px;
            flex-shrink: 0; 
            margin: 0 20px;
            padding-bottom: 20px;
        }
        .btn {
            padding: 10px 15px;
            border: 1px solid rgba(255, 255, 255, 0.5);
            border-radius: 0; /* Square corners */
            cursor: pointer;
            font-weight: bold;
            transition: background-color 0.3s, transform 0.2s;
            background-color: rgba(255, 255, 255, 0.4);
            color: #fff;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-grow: 0; 
            flex-shrink: 0; 
        }
        .btn:hover { background-color: rgba(255, 255, 255, 0.6); transform: translateY(-2px); }

        #save-note {
            background-color: rgba(40, 167, 69, 0.7);
            border-color: rgba(40, 167, 69, 1);
        }
        #save-note:hover {
             background-color: rgba(33, 136, 56, 0.9);
        }

        #delete-note { 
            background-color: rgba(220, 53, 69, 0.7); 
            border-color: rgba(220, 53, 69, 1); 
        }
        #delete-note:hover { 
            background-color: rgba(200, 48, 62, 0.9);
        }
        #delete-note svg { width: 1.2em; height: 1.2em; }

        #add-object-btn {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 12px 25px;
            background-color: #28a745;
            color: white;
            border: none;
            border-radius: 30px;
            font-size: 1em;
            font-weight: bold;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            cursor: pointer;
            transition: background-color 0.3s, transform 0.2s;
            z-index: 1001;
        }
        #add-object-btn:hover { background-color: #218838; transform: translateX(-50%) translateY(-2px); }
        .instructions { position: fixed; top: 20px; left: 20px; background: rgba(0, 0, 0, 0.6); color: white; padding: 10px 15px; border-radius: 8px; font-size: 0.9em; }
        .modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.6); display: flex; justify-content: center; align-items: center; z-index: 1001; }
        .modal-content {
            background: rgba(20, 20, 30, 0.9);
            color: white;
            padding: 25px;
            border-radius: 0;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            text-align: center;
            width: 90%;
            max-width: 400px;
            border: 1px solid rgba(255, 255, 255, 0.5);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
        }
        .modal-buttons { display: flex; justify-content: center; gap: 15px; margin-top: 20px; }
        #modal-confirm-btn { background-color: rgba(220, 53, 69, 0.7); border-color: rgba(220, 53, 69, 1); }
        #modal-confirm-btn:hover { background-color: rgba(200, 48, 62, 0.9); }
        #modal-cancel-btn { background-color: rgba(255, 255, 255, 0.2); border-color: rgba(255,255,255,0.5); }
        #modal-cancel-btn:hover { background-color: rgba(255, 255, 255, 0.4); }

        .resize-handle {
            position: absolute;
            width: 15px;
            height: 15px;
            z-index: 1001;
             background-image: repeating-linear-gradient(
                -45deg,
                transparent,
                transparent 4px,
                rgba(255, 255, 255, 0.5) 4px,
                rgba(255, 255, 255, 0.5) 5px
            );
        }
        #resize-handle-bl { bottom: 5px; left: 5px; cursor: nesw-resize; }
        #resize-handle-br { bottom: 5px; right: 5px; cursor: nwse-resize; }

        #close-btn { position: absolute; top: 5px; right: 5px; width: 20px; height: 20px; cursor: pointer; opacity: 0.8; transition: opacity 0.2s; }
        #close-btn:hover { opacity: 1; }
        #close-btn::before, #close-btn::after { content: ''; position: absolute; top: 9px; left: 2px; width: 16px; height: 2px; background-color: #fff; }
        #close-btn::before { transform: rotate(45deg); }
        #close-btn::after { transform: rotate(-45deg); }

        .object-ui {
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px;
            border: 1px solid rgba(255,255,255,0.4);
            width: 200px;
            pointer-events: auto !important;
            cursor: default;
        }
        .object-ui-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid rgba(255,255,255,0.4);
            padding-bottom: 5px;
            margin-bottom: 5px;
        }
        .object-ui-header h3 { margin: 0; font-size: 1.2em; }
        .edit-shape-btn { background: none; border: none; color: white; cursor: pointer; padding: 2px; }
        .edit-shape-btn svg { width: 16px; height: 16px; }
        .notes-list { list-style: none; padding: 0; margin: 0; }
        .notes-list li { padding: 5px; cursor: pointer; border-bottom: 1px solid rgba(255,255,255,0.2); }
        .notes-list li:hover { background: rgba(255,255,255,0.2); }
        .notes-list li:last-child { border-bottom: none; }
        .add-note-btn { background: rgba(255,255,255,0.2); border: none; color: white; width: 100%; padding: 5px; margin-top: 5px; cursor: pointer; }

        #shape-edit-panel {
             position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 300px;
            background: rgba(20, 20, 30, 0.9);
            border-radius: 0;
            box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.37);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            border: 1px solid rgba(255, 255, 255, 0.5);
            padding: 20px;
            display: none;
            flex-direction: column;
            gap: 15px;
            z-index: 1002;
            color: white;
        }
        .form-group { display: flex; flex-direction: column; gap: 5px; }
        .form-group input, .form-group select { background: rgba(255, 255, 255, 0.2); color: #fff; border: 1px solid rgba(255, 255, 255, 0.5); padding: 8px; }
        .form-group select option { color: black; background-color: white; }
        .form-group input[type="color"] { padding: 2px; height: 35px; }
        
        #line-connector {
            position: fixed;
            height: 2px;
            background-color: #000;
            transform-origin: 0 50%;
            pointer-events: none;
            display: none;
            z-index: 998;
            box-shadow: 0 0 0 1px rgba(255, 255, 255, 0.4);
        }
    </style>
</head>
<body>
    <div id="scene-container" tabindex="0"></div>
    <div id="line-connector"></div>

    <div class="instructions">
        <p>Use WASD/Arrow keys to move.</p>
        <p>Q/E to move vertically.</p>
        <p>Tab to cycle between objects.</p>
        <p>Click an object to view its notes.</p>
        <p>UI hides when you move away.</p>
    </div>
    <div id="ui-container">
        <div id="drag-handle"></div>
        <div id="close-btn" title="Close"></div>
        <input type="text" id="note-title" placeholder="Note Title">
        <textarea id="note-content" placeholder="Write your note here..."></textarea>
        <div class="button-group">
            <button id="save-note" class="btn">Save</button>
            <button id="delete-note" class="btn" title="Delete Object">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                    <path d="M5.5 5.5A.5.5 0 0 1 6 6v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5m2.5 0a.5.5 0 0 1 .5.5v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5m3 .5a.5.5 0 0 0-1 0v6a.5.5 0 0 0 1 0z"/>
                    <path d="M14.5 3a1 1 0 0 1-1 1H13v9a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V4h-.5a1 1 0 0 1-1-1V2a1 1 0 0 1 1-1H6a1 1 0 0 1 1-1h2a1 1 0 0 1 1 1h3.5a1 1 0 0 1 1 1zM4.118 4 4 4.059V13a1 1 0 0 0 1 1h6a1 1 0 0 0 1-1V4.059L11.882 4zM2.5 3V2h11v1z"/>
                </svg>
            </button>
        </div>
        <div id="resize-handle-bl" class="resize-handle"></div>
        <div id="resize-handle-br" class="resize-handle"></div>
    </div>
    <div id="shape-edit-panel">
        <h3>Edit Shape</h3>
        <div class="form-group">
            <label for="shape-name-input">Name</label>
            <input type="text" id="shape-name-input">
        </div>
        <div class="form-group">
            <label for="shape-type-select">Shape</label>
            <select id="shape-type-select">
                <option value="Box">Box</option>
                <option value="Sphere">Sphere</option>
                <option value="Cone">Cone</option>
                <option value="Torus">Torus</option>
            </select>
        </div>
         <div class="form-group">
            <label for="shape-color-input">Color</label>
            <input type="color" id="shape-color-input" value="#ffffff">
        </div>
        <button id="save-shape-btn" class="btn">Save Changes</button>
        <button id="close-shape-edit-btn" class="btn">Close</button>
    </div>

    <button id="add-object-btn">Add New Object</button>

    <div id="confirm-modal" class="modal-overlay" style="display: none;">
        <div class="modal-content">
            <p>Are you sure you want to delete this object and all its notes?</p>
            <div class="modal-buttons">
                <button id="modal-confirm-btn" class="btn">Yes, Delete</button>
                <button id="modal-cancel-btn" class="btn">Cancel</button>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/renderers/CSS2DRenderer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/FilmShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/FilmPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/geometries/DecalGeometry.js"></script>
    
    <script type="module">
        // =================================================================================
        // SECTION: GLOBAL VARIABLES & STATE
        // =================================================================================
        let scene, camera, renderer, controls, raycaster, mouse, composer, clock, labelRenderer, filmPass, decalMaterial;
        const objects = new Map(); // Moved up
        const decals = new Map();
        let selectedObject = null, editingObject = null, activeNote = { object: null, index: -1 }, lastIntersection = null, pendingNoteOpen = null, isDraggingCamera = false;
        let activeObjectUI = null, cycleIndex = -1, isCycling = false;
        const keyState = {};
        let isTyping = false;
        const moveSpeed = 0.1, DAMPING = 0.93; 
        let cameraVelocity = new THREE.Vector3();
        const sceneContainer = document.getElementById('scene-container'), uiContainer = document.getElementById('ui-container'), noteTitleInput = document.getElementById('note-title'), noteContentInput = document.getElementById('note-content'), saveNoteBtn = document.getElementById('save-note'), deleteNoteBtn = document.getElementById('delete-note'), closeBtn = document.getElementById('close-btn'), addObjectBtn = document.getElementById('add-object-btn'), confirmModal = document.getElementById('confirm-modal'), modalConfirmBtn = document.getElementById('modal-confirm-btn'), modalCancelBtn = document.getElementById('modal-cancel-btn'), resizeHandleBL = document.getElementById('resize-handle-bl'), resizeHandleBR = document.getElementById('resize-handle-br'), dragHandle = document.getElementById('drag-handle'), shapeEditPanel = document.getElementById('shape-edit-panel');
        let deleteAction = null;
        
        // =================================================================================
        // SECTION: LOCAL STORAGE PERSISTENCE
        // =================================================================================

        const STORAGE_KEY = 'astroMind-scene-data';
        let sceneData = new Map();

        function loadDataFromStorage() {
            const dataString = localStorage.getItem(STORAGE_KEY);
            if (dataString) {
                try {
                    const dataArray = JSON.parse(dataString);
                    sceneData = new Map(dataArray);
                } catch(e) {
                    console.error("Error parsing data from localStorage:", e);
                    sceneData = new Map();
                }
            } else {
                sceneData = new Map();
            }
        }

        function saveDataToStorage() {
            try {
                const dataArray = Array.from(sceneData.entries());
                localStorage.setItem(STORAGE_KEY, JSON.stringify(dataArray));
            } catch(e) {
                console.error("Error saving data to localStorage:", e);
            }
        }
        
        function rebuildSceneFromData() {
            // Clear existing scene objects (but not lights, ground, etc.)
            Array.from(objects.values()).forEach(obj => {
                if (obj.label && obj.label.element && obj.label.element.parentNode) {
                    obj.label.element.parentNode.removeChild(obj.label.element);
                }
                scene.remove(obj);
                removeDecal(obj.userData.id);
            });
            objects.clear();

            // Re-create objects from sceneData
            for (const [id, data] of sceneData.entries()) {
                createObjectFromData(data, id);
            }

            // After rebuilding, re-select object if it still exists
            const selectedId = selectedObject ? selectedObject.userData.id : null;
            if (selectedId && objects.has(selectedId)) {
                selectedObject = objects.get(selectedId);
                activeObjectUI = selectedObject.label;
                activeObjectUI.element.style.display = 'block';
            } else {
                selectedObject = null;
                activeObjectUI = null;
            }
        }


        function getGeometry(shape) {
            switch(shape) {
                case "Sphere": return new THREE.SphereGeometry(1, 32, 32);
                case "Cone": return new THREE.ConeGeometry(1, 2, 32);
                case "Torus": return new THREE.TorusGeometry(1, 0.4, 16, 100);
                case "Box": default: return new THREE.BoxGeometry(1.5, 1.5, 1.5);
            }
        }

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000005);
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(5, 5, 10);
            clock = new THREE.Clock();
            
            const decalCanvas = document.createElement('canvas'); decalCanvas.width = 128; decalCanvas.height = 128; const ctx = decalCanvas.getContext('2d'); ctx.fillStyle = '#f9e79f'; ctx.fillRect(0, 0, 128, 128); ctx.fillStyle = '#f4d03f'; ctx.fillRect(0, 0, 128, 15); ctx.fillStyle = 'rgba(0,0,0,0.1)'; ctx.fillRect(120, 0, 8, 128); ctx.fillRect(0, 120, 128, 8); const decalTexture = new THREE.CanvasTexture(decalCanvas);
            decalMaterial = new THREE.MeshStandardMaterial({ map: decalTexture, polygonOffset: true, polygonOffsetFactor: -4, transparent: true, opacity: 0.9 });
            const starsGeometry = new THREE.BufferGeometry(); const starsVertices = []; for (let i = 0; i < 20000; i++) { starsVertices.push(THREE.MathUtils.randFloatSpread(2000)); starsVertices.push(THREE.MathUtils.randFloatSpread(2000)); starsVertices.push(THREE.MathUtils.randFloatSpread(2000)); } starsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starsVertices, 3)); const starsMaterial = new THREE.PointsMaterial({ color: 0xffffff, size: 0.15, transparent: true, blending: THREE.AdditiveBlending }); scene.add(new THREE.Points(starsGeometry, starsMaterial));
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true }); renderer.setSize(window.innerWidth, window.innerHeight); renderer.setPixelRatio(window.devicePixelRatio); renderer.shadowMap.enabled = true; sceneContainer.appendChild(renderer.domElement);
            labelRenderer = new THREE.CSS2DRenderer(); labelRenderer.setSize(window.innerWidth, window.innerHeight); labelRenderer.domElement.style.position = 'absolute'; labelRenderer.domElement.style.top = '0px'; labelRenderer.domElement.style.pointerEvents = 'none'; sceneContainer.appendChild(labelRenderer.domElement);
            scene.add(new THREE.AmbientLight(0xffffff, 0.6)); const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8); directionalLight.position.set(10, 20, 5); directionalLight.castShadow = true; scene.add(directionalLight);
            const plane = new THREE.Mesh( new THREE.PlaneGeometry(100, 100), new THREE.MeshStandardMaterial({ color: 0xcccccc, roughness: 0.8, metalness: 0.1, transparent: true, opacity: 0.25 }) ); plane.rotation.x = -Math.PI / 2; plane.receiveShadow = true; scene.add(plane);
            controls = new THREE.OrbitControls(camera, renderer.domElement); Object.assign(controls, { enableDamping: true, dampingFactor: 0.05, minDistance: 3, maxDistance: 50, maxPolarAngle: Math.PI / 2.1, enableKeys: false });
            controls.addEventListener('start', () => { isDraggingCamera = true; });
            controls.addEventListener('end', () => { setTimeout(() => { isDraggingCamera = false; }, 0); });
            raycaster = new THREE.Raycaster(); mouse = new THREE.Vector2();
            composer = new THREE.EffectComposer(renderer); composer.addPass(new THREE.RenderPass(scene, camera)); const RetroShader = { uniforms: { 'tDiffuse': { value: null } }, vertexShader: `varying vec2 vUv; void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 ); }`, fragmentShader: `uniform sampler2D tDiffuse; varying vec2 vUv; void main() { vec2 offset = vec2(0.0015, 0.0015); vec4 cr = texture2D(tDiffuse, vUv + offset); vec4 cg = texture2D(tDiffuse, vUv); vec4 cb = texture2D(tDiffuse, vUv - offset); gl_FragColor = vec4(cr.r, cg.g, cb.b, cg.a); float vignette = 1.0 - smoothstep(0.4, 0.9, distance(vUv, vec2(0.5))); gl_FragColor.rgb *= vignette;}`}; composer.addPass(new THREE.ShaderPass(RetroShader)); filmPass = new THREE.FilmPass(0.3, 0.2, 1024, false); composer.addPass(filmPass);
            window.addEventListener('resize', onWindowResize); window.addEventListener('keydown', (event) => { if(event.key === "Tab") { event.preventDefault(); if (!isTyping) cycleToObject(); } else { keyState[event.code] = true; } }); window.addEventListener('keyup', (event) => { keyState[event.code] = false; }); sceneContainer.addEventListener('mousedown', (e) => { sceneContainer.focus(); }); sceneContainer.addEventListener('click', onObjectClick);
            noteTitleInput.addEventListener('focus', () => { isTyping = true; }); noteTitleInput.addEventListener('blur', () => { isTyping = false; }); noteContentInput.addEventListener('focus', () => { isTyping = true; }); noteContentInput.addEventListener('blur', () => { isTyping = false; });
            addObjectBtn.addEventListener('click', handleAddNewObjectClick); saveNoteBtn.addEventListener('click', saveNote); deleteNoteBtn.addEventListener('click', handleDeleteClick); closeBtn.addEventListener('click', closeNoteEditorWithAnimation); modalConfirmBtn.addEventListener('click', () => { if (deleteAction) deleteAction(); }); modalCancelBtn.addEventListener('click', hideModal);
            document.getElementById('save-shape-btn').addEventListener('click', saveShapeChanges); document.getElementById('close-shape-edit-btn').addEventListener('click', () => { shapeEditPanel.style.display = 'none'; editingObject = null; });
            initResizeBR(uiContainer, resizeHandleBR); initResizeBL(uiContainer, resizeHandleBL); initDrag(uiContainer, dragHandle);
            
            loadDataFromStorage();
            rebuildSceneFromData();
            animate();
        }

        function initDrag(element, handle) { let startX, startY, startLeft, startTop; function doDrag(e) { e.preventDefault(); element.style.right = "auto"; element.style.left = (startLeft + e.clientX - startX) + 'px'; element.style.top = (startTop + e.clientY - startY) + 'px'; } function stopDrag() { document.documentElement.removeEventListener('mousemove', doDrag, false); document.documentElement.removeEventListener('mouseup', stopDrag, false); } handle.addEventListener('mousedown', (e) => { e.preventDefault(); e.stopPropagation(); startX = e.clientX; startY = e.clientY; const rect = element.getBoundingClientRect(); startLeft = rect.left; startTop = rect.top; document.documentElement.addEventListener('mousemove', doDrag, false); document.documentElement.addEventListener('mouseup', stopDrag, false); }, false); }
        function initResizeBL(element, handle) { let startX, startY, startWidth, startHeight, startLeft; function doDrag(e) { e.preventDefault(); element.style.right = 'auto'; element.style.width = (startWidth - (e.clientX - startX)) + 'px'; element.style.height = (startHeight + (e.clientY - startY)) + 'px'; element.style.left = (startLeft + (e.clientX - startX)) + 'px'; } function stopDrag() { document.documentElement.removeEventListener('mousemove', doDrag, false); document.documentElement.removeEventListener('mouseup', stopDrag, false); } handle.addEventListener('mousedown', (e) => { e.preventDefault(); e.stopPropagation(); startX = e.clientX; startY = e.clientY; const rect = element.getBoundingClientRect(); startWidth = rect.width; startHeight = rect.height; startLeft = rect.left; document.documentElement.addEventListener('mousemove', doDrag, false); document.documentElement.addEventListener('mouseup', stopDrag, false); }, false); }
        function initResizeBR(element, handle) { let startX, startY, startWidth, startHeight; function doDrag(e) { e.preventDefault(); element.style.width = (startWidth + (e.clientX - startX)) + 'px'; element.style.height = (startHeight + (e.clientY - startY)) + 'px'; } function stopDrag() { document.documentElement.removeEventListener('mousemove', doDrag, false); document.documentElement.removeEventListener('mouseup', stopDrag, false); } handle.addEventListener('mousedown', (e) => { e.preventDefault(); e.stopPropagation(); startX = e.clientX; startY = e.clientY; const rect = element.getBoundingClientRect(); startWidth = rect.width; startHeight = rect.height; element.style.left = rect.left + 'px'; element.style.right = 'auto'; document.documentElement.addEventListener('mousemove', doDrag, false); document.documentElement.addEventListener('mouseup', stopDrag, false); }, false); }
        
        function handleAddNewObjectClick() { editingObject = null; showShapeEditPanel(); }
        
        function saveNote() { if (!activeNote.object || activeNote.index < 0) return; const objectId = activeNote.object.userData.id; const objectData = sceneData.get(objectId); if (!objectData) return; const notes = [...(objectData.notes || [])]; notes[activeNote.index] = { title: noteTitleInput.value, content: noteContentInput.value }; const hasAnyNoteContent = notes.some(note => note.title || note.content); if (hasAnyNoteContent && !objectData.decal && lastIntersection) { const orientation = new THREE.Euler(); const matrix = new THREE.Matrix4().lookAt(lastIntersection.point, lastIntersection.point.clone().sub(lastIntersection.face.normal), activeNote.object.up); orientation.setFromRotationMatrix(matrix); objectData.decal = { position: lastIntersection.point.clone().applyMatrix4(new THREE.Matrix4().copy(activeNote.object.matrixWorld).invert()), orientation: {x: orientation.x, y: orientation.y, z: orientation.z} }; } else if (!hasAnyNoteContent) { objectData.decal = null; } objectData.notes = notes; sceneData.set(objectId, objectData); saveDataToStorage(); rebuildSceneFromData(); closeNoteEditorWithAnimation(); }
        function closeNoteEditorWithAnimation() { uiContainer.classList.add('closing'); uiContainer.addEventListener('animationend', () => { uiContainer.style.display = 'none'; uiContainer.classList.remove('closing'); activeNote = { object: null, index: -1 }; lastIntersection = null; }, { once: true }); }
        
        function saveShapeChanges() { const newName = document.getElementById('shape-name-input').value; const newShape = document.getElementById('shape-type-select').value; const newColor = document.getElementById('shape-color-input').value; if (editingObject) { const objectId = editingObject.userData.id; const objectData = sceneData.get(objectId); if (objectData) { objectData.name = newName; objectData.shape = newShape; objectData.color = newColor; sceneData.set(objectId, objectData); } } else { const newId = crypto.randomUUID(); sceneData.set(newId, { name: newName, shape: newShape, color: newColor, position: { x: (Math.random() - 0.5) * 20, y: Math.random() * 2 + 1, z: (Math.random() - 0.5) * 20 }, notes: [], decal: null }); } saveDataToStorage(); rebuildSceneFromData(); shapeEditPanel.style.display = 'none'; editingObject = null; }
        
        function handleDeleteClick() { if (!activeNote.object) return; confirmModal.style.display = 'flex'; deleteAction = () => { fadeAndDeleteObject(activeNote.object); hideModal(); if(activeObjectUI) activeObjectUI.element.style.display = 'none'; activeObjectUI = null; }; }
        function fadeAndDeleteObject(objectToDelete) { const objectId = objectToDelete.userData.id; const duration = 500; const startTime = performance.now(); objectToDelete.traverse((child) => { if(child.isMesh) { child.material = child.material.clone(); child.material.transparent = true; } }); const decal = decals.get(objectId); if (decal) decal.material.transparent = true; function fade() { const progress = Math.min((performance.now() - startTime) / duration, 1); const opacity = 1 - progress; objectToDelete.traverse((child) => { if(child.isMesh) child.material.opacity = opacity; }); if (decal) decal.material.opacity = opacity; if (progress < 1) requestAnimationFrame(fade); else { sceneData.delete(objectId); saveDataToStorage(); rebuildSceneFromData(); } } requestAnimationFrame(fade); }
        function hideModal() { confirmModal.style.display = 'none'; deleteAction = null; }
        
        function removeDecal(objectId) { if(decals.has(objectId)) { const decal = decals.get(objectId); scene.remove(decal); decal.geometry.dispose(); decals.delete(objectId); } }
        function placeOrUpdateDecal(objectId, data) { removeDecal(objectId); const parentObject = objects.get(objectId); if (!parentObject || !data.decal) return; const position = new THREE.Vector3().copy(data.decal.position).applyMatrix4(parentObject.matrixWorld); const orientation = new THREE.Euler().copy(data.decal.orientation); const size = new THREE.Vector3(0.75, 0.75, 0.75); const decalGeom = new THREE.DecalGeometry(parentObject, position, orientation, size); const decal = new THREE.Mesh(decalGeom, decalMaterial); decals.set(objectId, decal); scene.add(decal); }
        
        function createObjectFromData(data, id) { const geometry = getGeometry(data.shape); const material = new THREE.MeshStandardMaterial({ color: data.color || "#ffffff", roughness: 0.5, metalness: 0.1 }); const mesh = new THREE.Mesh(geometry, material); mesh.position.set(data.position.x, data.position.y, data.position.z); mesh.castShadow = true; mesh.receiveShadow = true; mesh.userData = { id, data }; const objectDiv = document.createElement('div'); objectDiv.className = 'object-ui'; const header = document.createElement('div'); header.className = 'object-ui-header'; const title = document.createElement('h3'); title.textContent = data.name; const editBtn = document.createElement('button'); editBtn.className = 'edit-shape-btn'; editBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M12.854.146a.5.5 0 0 0-.707 0L10.5 1.793 14.207 5.5l1.647-1.646a.5.5 0 0 0 0-.708l-3-3zm.646 6.061L9.793 2.5 3.293 9H3.5a.5.5 0 0 1 .5.5v.5h.5a.5.5 0 0 1 .5.5v.5h.5a.5.5 0 0 1 .5.5v.5h.5a.5.5 0 0 1 .5.5v.207l6.5-6.5zm-7.468 7.468A.5.5 0 0 1 6 13.5V13h-.5a.5.5 0 0 1-.5-.5V12h-.5a.5.5 0 0 1-.5-.5V11h-.5a.5.5 0 0 1-.5-.5V10h-.5a.499.499 0 0 1-.175-.032l-.179.178a.5.5 0 0 0-.11.168l-2 5a.5.5 0 0 0 .65.65l5-2a.5.5 0 0 0 .168-.11l.178-.178z"/></svg>`; editBtn.onclick = (e) => { e.stopPropagation(); showShapeEditPanel(mesh); }; header.appendChild(title); header.appendChild(editBtn); const notesList = document.createElement('ul'); notesList.className = 'notes-list'; (data.notes || []).forEach((note, index) => { const li = document.createElement('li'); li.textContent = note.title || `Note ${index + 1}`; li.onclick = (e) => { e.stopPropagation(); openNoteEditor(mesh, index); }; notesList.appendChild(li); }); const addNoteBtn = document.createElement('button'); addNoteBtn.className = 'add-note-btn'; addNoteBtn.textContent = '+ New Note'; addNoteBtn.onclick = (e) => { e.stopPropagation(); addNewNote(mesh); }; objectDiv.appendChild(header); objectDiv.appendChild(notesList); objectDiv.appendChild(addNoteBtn); const objectLabel = new THREE.CSS2DObject(objectDiv); objectLabel.position.set(0, 1.5, 0); mesh.add(objectLabel); mesh.label = objectLabel; objectLabel.element.style.display = 'none'; scene.add(mesh); objects.set(id, mesh); placeOrUpdateDecal(id, data); }
        function showShapeEditPanel(object = null) { editingObject = object; if (editingObject) { const data = editingObject.userData.data; document.getElementById('shape-name-input').value = data.name; document.getElementById('shape-type-select').value = data.shape; document.getElementById('shape-color-input').value = data.color; } else { document.getElementById('shape-name-input').value = "New Shape"; document.getElementById('shape-type-select').value = "Box"; document.getElementById('shape-color-input').value = "#" + Math.floor(Math.random()*16777215).toString(16).padStart(6, '0'); } shapeEditPanel.style.display = 'flex'; }
        
        function addNewNote(object) {
            const objectId = object.userData.id;
            const objectData = sceneData.get(objectId);
            if (!objectData) return;
            const notes = objectData.notes || [];
            let highestNoteNumber = 0;
            notes.forEach(note => {
                if (note.title && note.title.startsWith('Note ')) {
                    const numberPart = note.title.substring(5);
                    const noteNumber = parseInt(numberPart, 10);
                    if (!isNaN(noteNumber) && noteNumber > highestNoteNumber) {
                        highestNoteNumber = noteNumber;
                    }
                }
            });
            const newNoteTitle = `Note ${highestNoteNumber + 1}`;
            const newNoteIndex = notes.length;
            notes.push({title: newNoteTitle, content: ''});
            objectData.notes = notes;
            sceneData.set(objectId, objectData);
            saveDataToStorage();
            rebuildSceneFromData();
            pendingNoteOpen = { objectId, noteIndex: newNoteIndex };
        }

        function openNoteEditor(object, index) { activeNote = { object, index }; const note = object.userData.data.notes[index]; updateUIPanel(note); uiContainer.style.display = 'flex'; }
        function updateUIPanel(note) { noteTitleInput.value = note.title || ""; noteContentInput.value = note.content || ""; }
        function handleCameraMovement() { const moveDirection = new THREE.Vector3(); if (!isTyping) { const forward = new THREE.Vector3(); camera.getWorldDirection(forward); const right = new THREE.Vector3().crossVectors(forward, camera.up); if (keyState['KeyW'] || keyState['ArrowUp']) moveDirection.add(forward); if (keyState['KeyS'] || keyState['ArrowDown']) moveDirection.sub(forward); if (keyState['KeyA'] || keyState['ArrowLeft']) moveDirection.sub(right); if (keyState['KeyD'] || keyState['ArrowRight']) moveDirection.add(right); if (keyState['KeyE']) moveDirection.y += 1; if (keyState['KeyQ']) moveDirection.y -= 1; } if (moveDirection.lengthSq() > 0) cameraVelocity.copy(moveDirection.normalize().multiplyScalar(moveSpeed)); camera.position.add(cameraVelocity); controls.target.add(cameraVelocity); cameraVelocity.multiplyScalar(DAMPING); }
        
        function onObjectClick(event) {
            if (isDraggingCamera) return;
            const uiElements = document.querySelectorAll('.object-ui, #ui-container, #shape-edit-panel, #add-object-btn, #confirm-modal');
            for(const el of uiElements) {
                if (el.contains(event.target)) return;
            }
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(Array.from(objects.values()), true);
            
            if (intersects.length > 0) {
                lastIntersection = intersects[0];
                let clickedObject = lastIntersection.object;
                while(clickedObject.parent && !clickedObject.userData.id) {
                    clickedObject = clickedObject.parent;
                }
                if(clickedObject.userData.id && objects.has(clickedObject.userData.id)) {
                    if (selectedObject && selectedObject.userData.id === clickedObject.userData.id) return;
                    if (activeObjectUI) activeObjectUI.element.style.display = 'none';
                    selectedObject = objects.get(clickedObject.userData.id);
                    activeObjectUI = selectedObject.label;
                    activeObjectUI.element.style.display = 'block';
                }
            } else {
                if (activeObjectUI) {
                    activeObjectUI.element.style.display = 'none';
                    activeObjectUI = null;
                }
                selectedObject = null;
                lastIntersection = null;
            }
        }

        function checkObjectUIDistance() { if (activeObjectUI && selectedObject) { const distance = camera.position.distanceTo(selectedObject.position); if (distance > 20) { activeObjectUI.element.style.display = 'none'; activeObjectUI = null; selectedObject = null; } } }
        function cycleToObject() { const objectArray = Array.from(objects.values()); if(objectArray.length === 0 || isCycling) return; isCycling = true; cycleIndex = (cycleIndex + 1) % objectArray.length; const targetObject = objectArray[cycleIndex]; const targetPosition = targetObject.position.clone(); const direction = new THREE.Vector3().subVectors(camera.position, targetPosition).normalize(); const newCameraPosition = new THREE.Vector3().addVectors(targetPosition, direction.multiplyScalar(10)); const duration = 500; const startPos = camera.position.clone(); const startTarget = controls.target.clone(); let elapsed = 0; function animateCycle(timestamp) { if(!isCycling) return; elapsed += clock.getDelta() * 1000; const t = Math.min(1, elapsed / duration); camera.position.lerpVectors(startPos, newCameraPosition, t); controls.target.lerpVectors(startTarget, targetPosition, t); if (t < 1) requestAnimationFrame(animateCycle); else isCycling = false; } requestAnimationFrame(animateCycle); }
        function onWindowResize() { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); labelRenderer.setSize(window.innerWidth, window.innerHeight); composer.setSize(window.innerWidth, window.innerHeight); }
        
        function updateLineConnector() {
            const lineConnector = document.getElementById('line-connector');
            if (activeNote.object && uiContainer.style.display !== 'none') {
                const objectPosition = activeNote.object.position.clone();
                objectPosition.project(camera);
                const screenX = (objectPosition.x * 0.5 + 0.5) * renderer.domElement.clientWidth;
                const screenY = (-objectPosition.y * 0.5 + 0.5) * renderer.domElement.clientHeight;
                const uiRect = uiContainer.getBoundingClientRect();
                const uiX = uiRect.left;
                const uiY = uiRect.top + uiRect.height / 2;
                const dx = screenX - uiX;
                const dy = screenY - uiY;
                const length = Math.hypot(dx, dy);
                const angle = Math.atan2(dy, dx) * (180 / Math.PI);
                lineConnector.style.left = `${uiX}px`;
                lineConnector.style.top = `${uiY}px`;
                lineConnector.style.width = `${length}px`;
                lineConnector.style.transform = `rotate(${angle}deg)`;
                lineConnector.style.display = 'block';
            } else {
                lineConnector.style.display = 'none';
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            if(!isCycling) handleCameraMovement();
            controls.update();
            checkObjectUIDistance();
            updateLineConnector();
            filmPass.uniforms.time.value = clock.getElapsedTime();
            composer.render();
            labelRenderer.render(scene, camera);
        }

        // Initial call
        init();
    </script>
</body>
</html>

