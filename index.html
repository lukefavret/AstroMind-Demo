<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Note Taker</title>
    <!--
      AstroMind-Demo single-file application
      - Vision: Analog Sciâ€‘Fi aesthetic (CRT vibes, frosty glass UI) supporting spatial cognition
      - Engine: Three.js (no bundler). Persistence via localStorage only. Deployed as a static page.
      - Interaction: WASD/QE + mouse, Tab to cycle objects, click objects to open on-object UI.
      - Accessibility: UI disables navigation when typing; distance-based UI auto-hide reduces clutter.
      Editing: All logic lives here. Reload the page after edits.
    -->
    <style>
        /* ===============================
           Base + Global Aesthetic
           =============================== */
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            overflow: hidden;
            background-color: #000005;
            color: #333;
        }
        /* Full-screen WebGL mount */
        #scene-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            cursor: grab;
        }
        #scene-container:focus {
            outline: none; /* Removes the blue outline on focus */
        }

        /* ===============================
           Note Editor Panel (frosty glass)
           =============================== */
        .note-editor {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 300px;
            min-width: 250px; /* Minimum resize width */
            min-height: 250px; /* Minimum resize height */
            background: rgba(255, 255, 255, 0.1);
            border-radius: 0; /* Square corners */
            box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.37);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            border: 1px solid rgba(255, 255, 255, 0.5);
            padding-top: 30px; /* Make space for drag handle and close button */
            display: none;
            flex-direction: column;
            gap: 15px;
            max-height: calc(100vh - 40px);
            overflow: hidden; /* Changed from auto to hidden for resize */
            z-index: 1000;
            transform-origin: center;
        }

        /* CRT "power-off" close animation for note editor */
        .note-editor.closing {
            animation: crt-flicker-out 400ms forwards;
        }

        .note-editor.closing > * {
            visibility: hidden; /* Hide content during animation */
        }

        @keyframes crt-flicker-out {
            0% { transform: scale(1, 1); background-color: rgba(255, 255, 255, 0.1); backdrop-filter: blur(8px); -webkit-backdrop-filter: blur(8px); }
            40% { transform: scale(1, 0.01); background-color: white; backdrop-filter: blur(0px); -webkit-backdrop-filter: blur(0px); }
            80% { transform: scale(0.005, 0.005); background-color: white; }
            100% { transform: scale(0, 0); background-color: white; }
        }

        /* Drag handle targets mouse movement only (no visible chrome) */
        .note-editor .drag-handle {
            position: absolute;
            top: 0;
            left: 0;
            width: calc(100% - 30px); /* Leave space for close button */
            height: 30px;
            cursor: move;
        }

        .note-editor .note-title {
            font-size: 1.2em;
            font-weight: bold;
            color: #fff;
            border: none;
            background: transparent;
            border-bottom: 2px solid rgba(255, 255, 255, 0.5);
            padding: 8px 0;
            transition: border-color 0.3s;
            flex-shrink: 0;
            margin: 0 20px; /* Add margin to align with padding */
        }
        .note-editor .note-title:focus { outline: none; border-bottom-color: #fff; }
        .note-editor .note-title::placeholder { color: rgba(255, 255, 255, 0.7); }

        .note-editor .note-content {
            font-size: 1em;
            min-height: 150px;
            resize: none;
            background: rgba(255, 255, 255, 0.2);
            color: #fff;
            border: 1px solid rgba(255, 255, 255, 0.5);
            border-radius: 0; /* Square corners */
            padding: 10px;
            transition: border-color 0.3s, box-shadow 0.3s;
            flex-grow: 1;
            margin: 0 20px;
        }
        .note-editor .note-content:focus { outline: none; border-color: #fff; box-shadow: 0 0 5px rgba(255, 255, 255, 0.5); }
        .note-editor .note-content::placeholder { color: rgba(255, 255, 255, 0.7); }
        /* Action buttons in note editor */
        .button-group {
            display: flex;
            justify-content: flex-end; /* Align buttons to the right */
            gap: 10px;
            flex-shrink: 0;
            margin: 0 20px;
            padding-bottom: 20px;
        }

        .btn {
            padding: 10px 15px;
            border: 1px solid rgba(255, 255, 255, 0.5);
            border-radius: 0; /* Square corners */
            cursor: pointer;
            font-weight: bold;
            transition: background-color 0.3s, transform 0.2s;
            background-color: rgba(255, 255, 255, 0.4);
            color: #fff;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-grow: 0;
            flex-shrink: 0;
        }

        .btn:hover {
            background-color: rgba(255, 255, 255, 0.6);
            transform: translateY(-2px);
        }

        .note-editor .note-save-btn {
            background-color: rgba(40, 167, 69, 0.7);
            border-color: rgba(40, 167, 69, 1);
        }
        .note-editor .note-save-btn:hover {
             background-color: rgba(33, 136, 56, 0.9);
        }

        .note-editor .note-delete-btn, #delete-shape-btn {
            background-color: rgba(220, 53, 69, 0.7);
            border-color: rgba(220, 53, 69, 1);
        }
        .note-editor .note-delete-btn:hover, #delete-shape-btn:hover {
            background-color: rgba(200, 48, 62, 0.9);
        }
        #delete-note svg { width: 1.2em; height: 1.2em; }
        #delete-shape-btn { display: flex; align-items: center; gap: 6px; margin-right: auto; }
        #delete-shape-btn svg { width: 16px; height: 16px; }

        /* Global "Add Object" CTA */
        #add-object-btn {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 12px 25px;
            background-color: #28a745;
            color: white;
            border: none;
            border-radius: 30px;
            font-size: 1em;
            font-weight: bold;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            cursor: pointer;
            transition: background-color 0.3s, transform 0.2s;
            z-index: 1001;
        }
        #add-object-btn:hover { background-color: #218838; transform: translateX(-50%) translateY(-2px); }

        /* On-screen input help (non-blocking) */
        .instructions { position: fixed; top: 20px; left: 20px; background: rgba(0, 0, 0, 0.6); color: white; padding: 10px 15px; border-radius: 8px; font-size: 0.9em; }

        /* ===============================
           Modal (confirm destructive action)
           =============================== */
        .modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.6); display: flex; justify-content: center; align-items: center; z-index: 3000; }
        .modal-content {
            background: rgba(20, 20, 30, 0.9);
            color: white;
            padding: 25px;
            border-radius: 0;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            text-align: center;
            width: 90%;
            max-width: 400px;
            border: 1px solid rgba(255, 255, 255, 0.5);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            z-index: 3001;
        }
        .modal-buttons { display: flex; justify-content: center; gap: 15px; margin-top: 20px; }
        .modal-content h3 { margin: 0 0 15px 0; color: #fff; font-weight: 600; }
        .modal-input {
            width: 100%;
            padding: 10px;
            font-size: 1em;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.5);
            border-radius: 0;
            color: #fff;
            transition: border-color 0.3s, box-shadow 0.3s;
        }
        .modal-input:focus {
            outline: none;
            border-color: rgba(255, 255, 255, 0.9);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.15);
        }
        .input-error {
            border-color: rgba(220, 53, 69, 1) !important;
            box-shadow: 0 0 0 2px rgba(220, 53, 69, 0.4) !important;
        }
        #modal-confirm-btn { background-color: rgba(220, 53, 69, 0.7); border-color: rgba(220, 53, 69, 1); }
        #modal-confirm-btn:hover { background-color: rgba(200, 48, 62, 0.9); }
        #modal-cancel-btn { background-color: rgba(255, 255, 255, 0.2); border-color: rgba(255,255,255,0.5); }
        #modal-cancel-btn:hover { background-color: rgba(255, 255, 255, 0.4); }
        #name-prompt-confirm-btn { background-color: rgba(40, 167, 69, 0.7); border-color: rgba(40, 167, 69, 1); }
        #name-prompt-confirm-btn:hover { background-color: rgba(33, 136, 56, 0.9); }
        #name-prompt-cancel-btn { background-color: rgba(255, 255, 255, 0.2); border-color: rgba(255,255,255,0.5); }
        #name-prompt-cancel-btn:hover { background-color: rgba(255, 255, 255, 0.4); }

        /* Editor resize affordances */
        .note-editor .resize-handle {
            position: absolute;
            width: 18px;
            height: 18px;
            z-index: 1001;
            pointer-events: auto;
            transition: filter 0.2s ease;
        }
        .note-editor .resize-handle-bl {
            bottom: 5px;
            left: 5px;
            cursor: nesw-resize;
            background: linear-gradient(225deg, transparent 50%, rgba(255, 255, 255, 0.75) 50%);
        }
        .note-editor .resize-handle-br {
            bottom: 5px;
            right: 5px;
            cursor: nwse-resize;
            background: linear-gradient(135deg, transparent 50%, rgba(255, 255, 255, 0.75) 50%);
        }
        .note-editor .resize-handle-bl:hover, .note-editor .resize-handle-br:hover {
            filter: brightness(1.25);
        }

        /* Minimal close icon (kept simple for readability & CRT feel) */
        .note-editor .note-close-btn { position: absolute; top: 5px; right: 5px; width: 20px; height: 20px; cursor: pointer; opacity: 0.8; transition: opacity 0.2s; }
        .note-editor .note-close-btn:hover { opacity: 1; }
        .note-editor .note-close-btn::before, .note-editor .note-close-btn::after { content: ''; position: absolute; top: 9px; left: 2px; width: 16px; height: 2px; background-color: #fff; }
        .note-editor .note-close-btn::before { transform: rotate(45deg); }
        .note-editor .note-close-btn::after { transform: rotate(-45deg); }
        #shape-close-btn { position: absolute; top: 8px; right: 10px; width: 18px; height: 18px; cursor: pointer; opacity: 0.75; transition: opacity 0.2s; }
        #shape-close-btn:hover { opacity: 1; }
        #shape-close-btn::before, #shape-close-btn::after { content: ''; position: absolute; top: 8px; left: 2px; width: 14px; height: 2px; background-color: #fff; }
        #shape-close-btn::before { transform: rotate(45deg); }
        #shape-close-btn::after { transform: rotate(-45deg); }

        /* ===============================
           On-object UI card (CSS2D label)
           =============================== */
        .object-ui {
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px;
            border: 1px solid rgba(255,255,255,0.4);
            width: 200px;
            pointer-events: auto !important;
            cursor: default;
        }
        .object-ui-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid rgba(255,255,255,0.4);
            padding-bottom: 5px;
            margin-bottom: 5px;
        }
        .object-ui-header h3 { margin: 0; font-size: 1.2em; }
        .edit-shape-btn { background: none; border: none; color: white; cursor: pointer; padding: 2px; }
        .edit-shape-btn svg { width: 16px; height: 16px; }
        .notes-list { list-style: none; padding: 0; margin: 0; }
        .notes-list li { padding: 5px; cursor: pointer; border-bottom: 1px solid rgba(255,255,255,0.2); }
        .notes-list li:hover { background: rgba(255,255,255,0.2); }
        .notes-list li:last-child { border-bottom: none; }
        .add-note-btn { background: rgba(255,255,255,0.2); border: none; color: white; width: 100%; padding: 5px; margin-top: 5px; cursor: pointer; transition: background-color 0.2s ease, transform 0.2s ease, box-shadow 0.2s ease; }
        .add-note-btn:hover, .add-note-btn:focus { background: rgba(255,255,255,0.35); transform: translateY(-1px); box-shadow: 0 0 6px rgba(255,255,255,0.25); outline: 2px solid rgba(255,255,255,0.7); outline-offset: 2px; }

        /* Shape edit panel (object properties) */
        #shape-edit-panel {
             position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 300px;
            background: rgba(20, 20, 30, 0.9);
            border-radius: 0;
            box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.37);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            border: 1px solid rgba(255, 255, 255, 0.5);
            padding: 20px;
            display: none;
            flex-direction: column;
            gap: 15px;
            z-index: 1002;
            color: white;
        }
        .form-group { display: flex; flex-direction: column; gap: 5px; }
        .form-group input, .form-group select { background: rgba(255, 255, 255, 0.2); color: #fff; border: 1px solid rgba(255, 255, 255, 0.5); padding: 8px; }
        .form-group select option { color: black; background-color: white; }
        .form-group input[type="color"] { padding: 2px; height: 35px; }
        
        /* Screen-space connector line from editor to focused object */
        .note-connector {
            position: fixed;
            height: 2px;
            background-color: #000;
            transform-origin: 0 50%;
            pointer-events: none;
            display: none;
            z-index: 998;
            box-shadow: 0 0 0 1px rgba(255, 255, 255, 0.4);
        }
    </style>
    
        <!-- Editable settings (single-file friendly). You can tweak values below. -->
            <script type="application/json" id="app-settings">
            {
                "cycle": {
                    "durationMs": 350,
                    "distance": 10,
                    "easing": "easeInOutCubic"
                },
                "movement": {
                    "moveSpeed": 0.1,
                    "damping": 0.93
                },
                        "controls": {
                            "enableDamping": true,
                            "dampingFactor": 0.05,
                            "minDistance": 3,
                            "maxDistance": 50,
                            "maxPolarAngle": 1.494
                        },
                "post": {
                    "filmNoise": 0.3,
                    "filmScanlineIntensity": 0.2,
                    "filmScanlineCount": 1024,
                    "filmGrayscale": false,
                    "rgbOffset": 0.0015,
                    "vignetteStart": 0.4,
                    "vignetteEnd": 0.9
                },
                "ui": {
                    "labelHideDistance": 20,
                    "showConnector": true
                },
                "notes": {
                    "decalSize": 0.75,
                    "decalOpacity": 0.9
                }
            }
            </script>
</head>
<body>
    <!-- WebGL mount and 2D overlay renderers attach to this container -->
    <div id="scene-container" tabindex="0"></div>
    <div id="note-editors-root"></div>
    <template id="note-editor-template">
        <div class="note-editor" style="display: none;">
            <div class="drag-handle"></div>
            <div class="note-close-btn" title="Close"></div>
            <input type="text" class="note-title" placeholder="Note Title">
            <textarea class="note-content" placeholder="Write your note here..."></textarea>
            <div class="button-group">
                <button class="btn note-save-btn">Save</button>
                <button class="btn note-delete-btn" title="Delete">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                        <path d="M5.5 5.5A.5.5 0 0 1 6 6v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5m2.5 0a.5.5 0 0 1 .5.5v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5m3 .5a.5.5 0 0 0-1 0v6a.5.5 0 0 0 1 0z"/>
                        <path d="M14.5 3a1 1 0 0 1-1 1H13v9a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V4h-.5a1 1 0 0 1-1-1V2a1 1 0 0 1 1-1H6a1 1 0 0 1 1-1h2a1 1 0 0 1 1 1h3.5a1 1 0 0 1 1 1zM4.118 4 4 4.059V13a1 1 0 0 0 1 1h6a1 1 0 0 0 1-1V4.059L11.882 4zM2.5 3V2h11v1z"/>
                    </svg>
                </button>
            </div>
            <div class="resize-handle resize-handle-bl"></div>
            <div class="resize-handle resize-handle-br"></div>
        </div>
    </template>

    <!-- Lightweight instructions overlay to reduce cognitive load for first-time users -->
    <div class="instructions">
        <p>Use WASD/Arrow keys to move.</p>
        <p>Q/E to move vertically.</p>
        <p>Tab to cycle between objects.</p>
        <p>Click an object to view its notes.</p>
        <p>UI hides when you move away.</p>
    </div>
    <!-- Note editors are instantiated from the template above -->
    <!-- Edit currently selected object's shape, name, and color -->
    <div id="shape-edit-panel">
        <div id="shape-close-btn" title="Cancel"></div>
        <h3>Edit Shape</h3>
        <div class="form-group">
            <label for="shape-name-input">Name</label>
            <input type="text" id="shape-name-input">
        </div>
        <div class="form-group">
            <label for="shape-type-select">Shape</label>
            <select id="shape-type-select">
                <option value="Box">Box</option>
                <option value="Sphere">Sphere</option>
                <option value="Cone">Cone</option>
                <option value="Torus">Torus</option>
            </select>
        </div>
         <div class="form-group">
            <label for="shape-color-input">Color</label>
            <input type="color" id="shape-color-input" value="#ffffff">
        </div>
        <div class="button-group">
            <button id="delete-shape-btn" class="btn" title="Delete Object">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                    <path d="M5.5 5.5A.5.5 0 0 1 6 6v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5m2.5 0a.5.5 0 0 1 .5.5v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5m3 .5a.5.5 0 0 0-1 0v6a.5.5 0 0 0 1 0z"/>
                    <path d="M14.5 3a1 1 0 0 1-1 1H13v9a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V4h-.5a1 1 0 0 1-1-1V2a1 1 0 0 1 1-1H6a1 1 0 0 1 1-1h2a1 1 0 0 1 1 1h3.5a1 1 0 0 1 1 1zM4.118 4 4 4.059V13a1 1 0 0 0 1 1h6a1 1 0 0 0 1-1V4.059L11.882 4zM2.5 3V2h11v1z"/>
                </svg>
                Delete
            </button>
            <button id="save-shape-btn" class="btn">Save</button>
            <button id="close-shape-edit-btn" class="btn">Cancel</button>
        </div>
    </div>

    <button id="add-object-btn">Add New Object</button>

    <!-- Destructive action confirmation modal -->
    <div id="confirm-modal" class="modal-overlay" style="display: none;">
        <div class="modal-content">
            <p id="confirm-message">Are you sure?</p>
            <div class="modal-buttons">
                <button id="modal-confirm-btn" class="btn">Yes, Delete</button>
                <button id="modal-cancel-btn" class="btn">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Generic name prompt modal for new objects and notes -->
    <div id="name-prompt-modal" class="modal-overlay" style="display: none;">
        <div class="modal-content">
            <h3 id="name-prompt-title">Name Item</h3>
            <input id="name-prompt-input" class="modal-input" type="text" autocomplete="off">
            <div class="modal-buttons">
                <button id="name-prompt-confirm-btn" class="btn">Save</button>
                <button id="name-prompt-cancel-btn" class="btn">Cancel</button>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/renderers/CSS2DRenderer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/FilmShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/FilmPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/geometries/DecalGeometry.js"></script>
    
    <script type="module">
        // =================================================================================
        // Overview
        // =================================================================================
        /**
         * Spatial note-taking demo with an Analog Sciâ€‘Fi aesthetic.
         * - All state is persisted to localStorage as a Map of objectId -> ObjectData.
         * - 3D objects have on-object UI (CSS2D labels). A separate draggable editor handles note content.
         * - Keyboard navigation (WASD/QE) is disabled while typing to support focus and accessibility.
         */

        // =================================================================================
        // SECTION: GLOBAL VARIABLES & STATE
        // =================================================================================
    /** @type {THREE.Scene} */
    let scene, camera, renderer, controls, raycaster, mouse, composer, clock, labelRenderer, filmPass, decalMaterial, retroPass;
        /** Map of objectId -> THREE.Mesh (with .label: CSS2DObject) */
        const objects = new Map();
        const decals = new Map();
        // Selection + UI state
        let selectedObject = null, editingObject = null, lastIntersection = null, pendingNoteOpen = null, isDraggingCamera = false;
        const openEditors = new Map();
        let nextEditorZ = 1100;
        let cascadeIndex = 0;
        let activeObjectUI = null, cycleIndex = -1, isCycling = false;
    const keyState = {};
    let isTyping = false;
    // Settings state
    let SETTINGS = {};
    // Movement parameters (initialized from settings in init())
    let moveSpeed = 0.1, DAMPING = 0.93; // Simple momentum for camera movement
        let cameraVelocity = new THREE.Vector3();
        // DOM refs split for readability (was a single chained declaration)
        const sceneContainer = document.getElementById('scene-container');
        const editorsRoot = document.getElementById('note-editors-root');
        const noteEditorTemplate = document.getElementById('note-editor-template');
        const addObjectBtn = document.getElementById('add-object-btn');
    const confirmModal = document.getElementById('confirm-modal');
    const confirmMessage = document.getElementById('confirm-message');
        const modalConfirmBtn = document.getElementById('modal-confirm-btn');
        const modalCancelBtn = document.getElementById('modal-cancel-btn');
        const shapeEditPanel = document.getElementById('shape-edit-panel');
        const shapeCloseBtn = document.getElementById('shape-close-btn');
        const shapeNameInput = document.getElementById('shape-name-input');
        const shapeTypeSelect = document.getElementById('shape-type-select');
        const shapeColorInput = document.getElementById('shape-color-input');
        const namePromptModal = document.getElementById('name-prompt-modal');
        const namePromptTitle = document.getElementById('name-prompt-title');
        const namePromptInput = document.getElementById('name-prompt-input');
        const namePromptConfirmBtn = document.getElementById('name-prompt-confirm-btn');
        const namePromptCancelBtn = document.getElementById('name-prompt-cancel-btn');
        let deleteAction = null;
        let activeNamePrompt = null;
        let wasTypingBeforePrompt = false;
        let wasTypingBeforeShapeEdit = false;

        shapeNameInput.addEventListener('input', () => {
            if (shapeNameInput.classList.contains('input-error')) {
                shapeNameInput.classList.remove('input-error');
            }
        });
        
        // =================================================================================
        // SECTION: SETTINGS LOADER (single-file + localStorage overrides)
        // =================================================================================
        const SETTINGS_STORAGE_KEY = 'astroMind-settings-overrides';
        function deepMerge(target, src) {
            const out = Array.isArray(target) ? [...target] : { ...target };
            for (const [k, v] of Object.entries(src || {})) {
                if (v && typeof v === 'object' && !Array.isArray(v)) {
                    out[k] = deepMerge(out[k] || {}, v);
                } else {
                    out[k] = v;
                }
            }
            return out;
        }
        function loadSettings() {
            try {
                const tag = document.getElementById('app-settings');
                const base = tag ? JSON.parse(tag.textContent) : {};
                const overridesStr = localStorage.getItem(SETTINGS_STORAGE_KEY);
                const overrides = overridesStr ? JSON.parse(overridesStr) : {};
                SETTINGS = deepMerge(base, overrides);
            } catch (e) {
                console.warn('Failed to load settings, using defaults', e);
                SETTINGS = { cycle: { durationMs: 350, distance: 10, easing: 'easeInOutCubic' }, movement: { moveSpeed: 0.1, damping: 0.93 } };
            }
        }
        function getSetting(path, fallback) {
            const parts = path.split('.');
            let cur = SETTINGS;
            for (const p of parts) {
                if (cur && Object.prototype.hasOwnProperty.call(cur, p)) cur = cur[p];
                else return fallback;
            }
            return cur;
        }
        function saveSettingsOverrides(partial) {
            const overridesStr = localStorage.getItem(SETTINGS_STORAGE_KEY);
            const overrides = overridesStr ? JSON.parse(overridesStr) : {};
            const newOverrides = deepMerge(overrides, partial);
            localStorage.setItem(SETTINGS_STORAGE_KEY, JSON.stringify(newOverrides));
            SETTINGS = deepMerge(SETTINGS, partial);
        }
        function applySettings() {
            // Movement
            moveSpeed = getSetting('movement.moveSpeed', moveSpeed);
            DAMPING = getSetting('movement.damping', DAMPING);
            // Controls
            if (controls) {
                controls.enableDamping = getSetting('controls.enableDamping', controls.enableDamping);
                controls.dampingFactor = getSetting('controls.dampingFactor', controls.dampingFactor);
                controls.minDistance = getSetting('controls.minDistance', controls.minDistance);
                controls.maxDistance = getSetting('controls.maxDistance', controls.maxDistance);
                controls.maxPolarAngle = getSetting('controls.maxPolarAngle', controls.maxPolarAngle);
                controls.update();
            }
            // Post effects
            if (filmPass) {
                filmPass.uniforms.nIntensity.value = getSetting('post.filmNoise', filmPass.uniforms.nIntensity.value);
                filmPass.uniforms.sIntensity.value = getSetting('post.filmScanlineIntensity', filmPass.uniforms.sIntensity.value);
                filmPass.uniforms.sCount.value = getSetting('post.filmScanlineCount', filmPass.uniforms.sCount.value);
                filmPass.uniforms.grayscale.value = getSetting('post.filmGrayscale', filmPass.uniforms.grayscale.value);
            }
            // Retro shader pass uniforms (if exists)
            if (typeof retroPass !== 'undefined' && retroPass && retroPass.uniforms) {
                retroPass.uniforms.rgbOffset.value = getSetting('post.rgbOffset', retroPass.uniforms.rgbOffset.value);
                retroPass.uniforms.vigStart.value = getSetting('post.vignetteStart', retroPass.uniforms.vigStart.value);
                retroPass.uniforms.vigEnd.value = getSetting('post.vignetteEnd', retroPass.uniforms.vigEnd.value);
            }
            // Decals: update opacity live
            for (const [id, decal] of decals.entries()) {
                if (decal && decal.material) {
                    decal.material.opacity = getSetting('notes.decalOpacity', decal.material.opacity);
                    decal.material.needsUpdate = true;
                }
            }
        }
        // Small API for runtime tweaks from DevTools
        window.AstroMind = {
            get settings() { return SETTINGS; },
            set(partial) {
                saveSettingsOverrides(partial);
                applySettings();
            },
            resetSettings() {
                localStorage.removeItem(SETTINGS_STORAGE_KEY);
                loadSettings();
                applySettings();
            },
        };

        // =================================================================================
        // SECTION: LOCAL STORAGE PERSISTENCE
        // =================================================================================
        /**
         * Storage key for serializing the scene graph state to localStorage
         */
        const STORAGE_KEY = 'astroMind-scene-data';
        /**
         * @typedef {{title: string, content: string}} Note
         * @typedef {{x:number,y:number,z:number}} Vec3Plain
         * @typedef {{position: Vec3Plain, orientation: {x:number,y:number,z:number}}} DecalData
         * @typedef {{
         *   name: string,
         *   shape: 'Box'|'Sphere'|'Cone'|'Torus',
         *   color: string,
         *   position: Vec3Plain,
         *   notes: Note[],
         *   decal: DecalData|null
         * }} ObjectData
         * @type {Map<string, ObjectData>}
         */
        let sceneData = new Map();

        /** Load Map<string, ObjectData> from localStorage (if any). */
        function loadDataFromStorage() {
            const dataString = localStorage.getItem(STORAGE_KEY);
            if (dataString) {
                try {
                    const dataArray = JSON.parse(dataString);
                    sceneData = new Map(dataArray);
                } catch(e) {
                    console.error("Error parsing data from localStorage:", e);
                    sceneData = new Map();
                }
            } else {
                sceneData = new Map();
            }
        }

        /** Persist Map<string, ObjectData> to localStorage. */
        function saveDataToStorage() {
            try {
                const dataArray = Array.from(sceneData.entries());
                localStorage.setItem(STORAGE_KEY, JSON.stringify(dataArray));
            } catch(e) {
                console.error("Error saving data to localStorage:", e);
            }
        }

        // =================================================================================
        // SECTION: SHARED NAME ENTRY UTILITIES
        // =================================================================================
        /**
         * Determine the next sequential default name for a given prefix.
         * @param {string} prefix
         * @param {string[]} existingNames
         */
        function getNextSequentialName(prefix, existingNames = []) {
            let highest = 0;
            const pattern = new RegExp(`^${prefix}\\s*(\\d+)$`, 'i');
            for (const rawName of existingNames) {
                if (typeof rawName !== 'string') continue;
                const match = rawName.trim().match(pattern);
                if (!match) continue;
                const parsed = parseInt(match[1], 10);
                if (!Number.isNaN(parsed) && parsed > highest) highest = parsed;
            }
            return `${prefix} ${highest + 1}`;
        }

        /**
         * Display the shared naming modal, enforcing non-empty submissions.
         * @param {{
         *   title?: string,
         *   defaultValue?: string,
         *   confirmLabel?: string,
         *   onConfirm?: (value: string) => void,
         *   onCancel?: () => void
         * }} options
         */
        function openNamePrompt(options = {}) {
            const { title = 'Name Item', defaultValue = '', confirmLabel = 'Save', onConfirm, onCancel } = options;
            activeNamePrompt = { onConfirm, onCancel };
            namePromptTitle.textContent = title;
            namePromptInput.value = typeof defaultValue === 'string' ? defaultValue : '';
            namePromptInput.classList.remove('input-error');
            namePromptConfirmBtn.textContent = confirmLabel;
            namePromptModal.style.display = 'flex';
            wasTypingBeforePrompt = isTyping;
            isTyping = true;
            requestAnimationFrame(() => {
                namePromptInput.focus();
                namePromptInput.select();
            });
        }

        /** Hide and reset the shared naming modal. */
        function closeNamePrompt() {
            namePromptModal.style.display = 'none';
            namePromptInput.value = '';
            namePromptInput.classList.remove('input-error');
            namePromptConfirmBtn.textContent = 'Save';
            const restoreTyping = wasTypingBeforePrompt;
            wasTypingBeforePrompt = false;
            isTyping = restoreTyping;
            activeNamePrompt = null;
        }

        function handleNamePromptConfirm() {
            if (!activeNamePrompt) return;
            const value = namePromptInput.value.trim();
            if (!value) {
                namePromptInput.classList.add('input-error');
                namePromptInput.focus();
                return;
            }
            const { onConfirm } = activeNamePrompt;
            closeNamePrompt();
            if (typeof onConfirm === 'function') onConfirm(value);
        }

        function handleNamePromptCancel() {
            if (!activeNamePrompt) return;
            const { onCancel } = activeNamePrompt;
            closeNamePrompt();
            if (typeof onCancel === 'function') onCancel();
        }

        namePromptInput.addEventListener('input', () => {
            if (namePromptInput.classList.contains('input-error')) {
                namePromptInput.classList.remove('input-error');
            }
        });
        namePromptConfirmBtn.addEventListener('click', handleNamePromptConfirm);
        namePromptCancelBtn.addEventListener('click', handleNamePromptCancel);
        namePromptModal.addEventListener('click', (event) => {
            if (event.target === namePromptModal) handleNamePromptCancel();
        });
        window.addEventListener('keydown', (event) => {
            if (!activeNamePrompt) return;
            if (event.key === 'Enter') {
                event.preventDefault();
                handleNamePromptConfirm();
            } else if (event.key === 'Escape') {
                event.preventDefault();
                handleNamePromptCancel();
            }
        });

        /**
         * Rebuild the live 3D scene from persisted data. Safe to call after any mutation.
         * Keeps selections if the object still exists.
         */
        function rebuildSceneFromData() {
            // Clear existing scene objects (but not lights, ground, etc.)
            Array.from(objects.values()).forEach(obj => {
                if (obj.label && obj.label.element && obj.label.element.parentNode) {
                    obj.label.element.parentNode.removeChild(obj.label.element);
                }
                scene.remove(obj);
                removeDecal(obj.userData.id);
            });
            objects.clear();

            // Re-create objects from sceneData
            for (const [id, data] of sceneData.entries()) {
                createObjectFromData(data, id);
            }

            // After rebuilding, re-select object if it still exists
            const selectedId = selectedObject ? selectedObject.userData.id : null;
            if (selectedId && objects.has(selectedId)) {
                selectedObject = objects.get(selectedId);
                activeObjectUI = selectedObject.label;
                activeObjectUI.element.style.display = 'block';
            } else {
                selectedObject = null;
                activeObjectUI = null;
            }

            // Rebind open editors to refreshed meshes or close if object disappeared
            for (const editorState of Array.from(openEditors.values())) {
                const refreshedObject = objects.get(editorState.objectId);
                if (refreshedObject) {
                    editorState.object = refreshedObject;
                    syncEditorContent(editorState);
                } else {
                    destroyEditor(editorState, { skipAnimation: true });
                }
            }

            if (pendingNoteOpen) {
                const { objectId, noteIndex, intersection } = pendingNoteOpen;
                const targetObject = objects.get(objectId);
                if (targetObject) {
                    openNoteEditor(targetObject, noteIndex, { intersection });
                }
                pendingNoteOpen = null;
            }
        }


        /** Return geometry for a given shape name. */
        function getGeometry(shape) {
            switch(shape) {
                case "Sphere": return new THREE.SphereGeometry(1, 32, 32);
                case "Cone": return new THREE.ConeGeometry(1, 2, 32);
                case "Torus": return new THREE.TorusGeometry(1, 0.4, 16, 100);
                case "Box": default: return new THREE.BoxGeometry(1.5, 1.5, 1.5);
            }
        }

        /**
         * Initialize Three.js scene, UI event handlers, post-processing, and restore state.
         */
        function init() {
            // Load settings first
            loadSettings();
            moveSpeed = getSetting('movement.moveSpeed', 0.1);
            DAMPING = getSetting('movement.damping', 0.93);

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000005);
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(5, 5, 10);
            clock = new THREE.Clock();
            
            // Sticky note decal texture (subtle card look, fits analog/CRT aesthetic)
            const decalCanvas = document.createElement('canvas'); decalCanvas.width = 128; decalCanvas.height = 128; const ctx = decalCanvas.getContext('2d'); ctx.fillStyle = '#f9e79f'; ctx.fillRect(0, 0, 128, 128); ctx.fillStyle = '#f4d03f'; ctx.fillRect(0, 0, 128, 15); ctx.fillStyle = 'rgba(0,0,0,0.1)'; ctx.fillRect(120, 0, 8, 128); ctx.fillRect(0, 120, 128, 8); const decalTexture = new THREE.CanvasTexture(decalCanvas);
            decalMaterial = new THREE.MeshStandardMaterial({ map: decalTexture, polygonOffset: true, polygonOffsetFactor: -4, transparent: true, opacity: 0.9 });

            // Procedural star field for deep-space ambiance
            const starsGeometry = new THREE.BufferGeometry(); const starsVertices = []; for (let i = 0; i < 20000; i++) { starsVertices.push(THREE.MathUtils.randFloatSpread(2000)); starsVertices.push(THREE.MathUtils.randFloatSpread(2000)); starsVertices.push(THREE.MathUtils.randFloatSpread(2000)); } starsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starsVertices, 3)); const starsMaterial = new THREE.PointsMaterial({ color: 0xffffff, size: 0.15, transparent: true, blending: THREE.AdditiveBlending }); scene.add(new THREE.Points(starsGeometry, starsMaterial));

            // Core renderers
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true }); renderer.setSize(window.innerWidth, window.innerHeight); renderer.setPixelRatio(window.devicePixelRatio); renderer.shadowMap.enabled = true; sceneContainer.appendChild(renderer.domElement);
            labelRenderer = new THREE.CSS2DRenderer(); labelRenderer.setSize(window.innerWidth, window.innerHeight); labelRenderer.domElement.style.position = 'absolute'; labelRenderer.domElement.style.top = '0px'; labelRenderer.domElement.style.pointerEvents = 'none'; sceneContainer.appendChild(labelRenderer.domElement);

            // Lighting + subtle ground plane reference
            scene.add(new THREE.AmbientLight(0xffffff, 0.6)); const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8); directionalLight.position.set(10, 20, 5); directionalLight.castShadow = true; scene.add(directionalLight);
            const plane = new THREE.Mesh( new THREE.PlaneGeometry(100, 100), new THREE.MeshStandardMaterial({ color: 0xcccccc, roughness: 0.8, metalness: 0.1, transparent: true, opacity: 0.25 }) ); plane.rotation.x = -Math.PI / 2; plane.receiveShadow = true; scene.add(plane);

            // Orbit controls: rotation via mouse-drag; keyboard handled manually for custom momentum
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            Object.assign(controls, {
                enableDamping: getSetting('controls.enableDamping', true),
                dampingFactor: getSetting('controls.dampingFactor', 0.05),
                minDistance: getSetting('controls.minDistance', 3),
                maxDistance: getSetting('controls.maxDistance', 50),
                maxPolarAngle: getSetting('controls.maxPolarAngle', Math.PI / 2.1),
                enableKeys: false
            });
            controls.addEventListener('start', () => { isDraggingCamera = true; });
            controls.addEventListener('end', () => { setTimeout(() => { isDraggingCamera = false; }, 0); });
            raycaster = new THREE.Raycaster(); mouse = new THREE.Vector2();

            // Post-processing: subtle RGB offset + film scanlines (CRT flavor)
            composer = new THREE.EffectComposer(renderer);
            composer.addPass(new THREE.RenderPass(scene, camera));
            const RetroShader = {
                uniforms: { 'tDiffuse': { value: null }, 'rgbOffset': { value: getSetting('post.rgbOffset', 0.0015) }, 'vigStart': { value: getSetting('post.vignetteStart', 0.4) }, 'vigEnd': { value: getSetting('post.vignetteEnd', 0.9) } },
                vertexShader: `varying vec2 vUv; void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 ); }`,
                fragmentShader: `uniform sampler2D tDiffuse; uniform float rgbOffset; uniform float vigStart; uniform float vigEnd; varying vec2 vUv; void main() { vec2 offset = vec2(rgbOffset, rgbOffset); vec4 cr = texture2D(tDiffuse, vUv + offset); vec4 cg = texture2D(tDiffuse, vUv); vec4 cb = texture2D(tDiffuse, vUv - offset); gl_FragColor = vec4(cr.r, cg.g, cb.b, cg.a); float vignette = 1.0 - smoothstep(vigStart, vigEnd, distance(vUv, vec2(0.5))); gl_FragColor.rgb *= vignette; }`
            };
            const retroPass = new THREE.ShaderPass(RetroShader);
            composer.addPass(retroPass);
            filmPass = new THREE.FilmPass(
                getSetting('post.filmNoise', 0.3),
                getSetting('post.filmScanlineIntensity', 0.2),
                getSetting('post.filmScanlineCount', 1024),
                getSetting('post.filmGrayscale', false)
            );
            composer.addPass(filmPass);

            // Events: keep concise; prevent Tab from moving focus when cycling objects
            window.addEventListener('resize', onWindowResize);
            window.addEventListener('keydown', (event) => {
                if (activeNamePrompt) {
                    if (event.key === 'Tab') event.preventDefault();
                    return;
                }
                if (event.key === 'Tab') {
                    event.preventDefault();
                    if (!isTyping) cycleToObject();
                } else {
                    keyState[event.code] = true;
                }
            });
            window.addEventListener('keyup', (event) => { keyState[event.code] = false; });
            sceneContainer.addEventListener('mousedown', (e) => { sceneContainer.focus(); });
            sceneContainer.addEventListener('click', onObjectClick);

            // Primary UI actions
            addObjectBtn.addEventListener('click', handleAddNewObjectClick);
            modalConfirmBtn.addEventListener('click', () => { if (deleteAction) deleteAction(); });
            modalCancelBtn.addEventListener('click', hideModal);
            document.getElementById('save-shape-btn').addEventListener('click', saveShapeChanges);
            document.getElementById('close-shape-edit-btn').addEventListener('click', closeShapeEditPanel);
            shapeCloseBtn.addEventListener('click', closeShapeEditPanel);
            document.getElementById('delete-shape-btn').addEventListener('click', handleDeleteObjectFromShapeEditor);

            loadDataFromStorage();
            rebuildSceneFromData();
            animate();
        }

        /** Make an element draggable using a handle element. */
        function initDrag(element, handle) { let startX, startY, startLeft, startTop; function doDrag(e) { e.preventDefault(); element.style.right = "auto"; element.style.left = (startLeft + e.clientX - startX) + 'px'; element.style.top = (startTop + e.clientY - startY) + 'px'; } function stopDrag() { document.documentElement.removeEventListener('mousemove', doDrag, false); document.documentElement.removeEventListener('mouseup', stopDrag, false); } handle.addEventListener('mousedown', (e) => { e.preventDefault(); e.stopPropagation(); startX = e.clientX; startY = e.clientY; const rect = element.getBoundingClientRect(); startLeft = rect.left; startTop = rect.top; document.documentElement.addEventListener('mousemove', doDrag, false); document.documentElement.addEventListener('mouseup', stopDrag, false); }, false); }
        /** Resize from bottom-left handle. Keeps right edge fixed by switching to left positioning. */
        function initResizeBL(element, handle) { let startX, startY, startWidth, startHeight, startLeft; function doDrag(e) { e.preventDefault(); element.style.right = 'auto'; element.style.width = (startWidth - (e.clientX - startX)) + 'px'; element.style.height = (startHeight + (e.clientY - startY)) + 'px'; element.style.left = (startLeft + (e.clientX - startX)) + 'px'; } function stopDrag() { document.documentElement.removeEventListener('mousemove', doDrag, false); document.documentElement.removeEventListener('mouseup', stopDrag, false); } handle.addEventListener('mousedown', (e) => { e.preventDefault(); e.stopPropagation(); startX = e.clientX; startY = e.clientY; const rect = element.getBoundingClientRect(); startWidth = rect.width; startHeight = rect.height; startLeft = rect.left; document.documentElement.addEventListener('mousemove', doDrag, false); document.documentElement.addEventListener('mouseup', stopDrag, false); }, false); }
        /** Resize from bottom-right handle. */
        function initResizeBR(element, handle) { let startX, startY, startWidth, startHeight; function doDrag(e) { e.preventDefault(); element.style.width = (startWidth + (e.clientX - startX)) + 'px'; element.style.height = (startHeight + (e.clientY - startY)) + 'px'; } function stopDrag() { document.documentElement.removeEventListener('mousemove', doDrag, false); document.documentElement.removeEventListener('mouseup', stopDrag, false); } handle.addEventListener('mousedown', (e) => { e.preventDefault(); e.stopPropagation(); startX = e.clientX; startY = e.clientY; const rect = element.getBoundingClientRect(); startWidth = rect.width; startHeight = rect.height; element.style.left = rect.left + 'px'; element.style.right = 'auto'; document.documentElement.addEventListener('mousemove', doDrag, false); document.documentElement.addEventListener('mouseup', stopDrag, false); }, false); }
        
        /** Open shape editor for new object creation. */
        function handleAddNewObjectClick() { showShapeEditPanel(); }
        
        function getEditorKey(objectId, noteIndex) {
            return `${objectId}:${noteIndex}`;
        }

        function captureIntersectionSnapshot(intersection) {
            if (!intersection) return null;
            return {
                point: intersection.point.clone(),
                normal: intersection.face && intersection.face.normal ? intersection.face.normal.clone() : null,
            };
        }

        function focusEditor(editorState) {
            if (!editorState || !editorState.element) return;
            editorState.element.style.zIndex = `${++nextEditorZ}`;
            if (editorState.connector) {
                if (!editorState.connector.isConnected) {
                    editorsRoot.appendChild(editorState.connector);
                }
                editorState.connector.style.zIndex = `${nextEditorZ - 1}`;
            }
        }

        function attachEditorEvents(editorState) {
            const { element, dragHandle, resizeBL, resizeBR, titleInput, contentInput, saveBtn, deleteBtn, closeBtn } = editorState;
            if (dragHandle) initDrag(element, dragHandle);
            if (resizeBL) initResizeBL(element, resizeBL);
            if (resizeBR) initResizeBR(element, resizeBR);

            element.addEventListener('mousedown', () => focusEditor(editorState));
            element.addEventListener('focusin', () => focusEditor(editorState));

            const markTyping = () => { isTyping = true; };
            const clearTyping = () => { isTyping = false; };
            titleInput.addEventListener('focus', markTyping);
            titleInput.addEventListener('blur', clearTyping);
            contentInput.addEventListener('focus', markTyping);
            contentInput.addEventListener('blur', clearTyping);

            saveBtn.addEventListener('click', () => saveNote(editorState));
            deleteBtn.addEventListener('click', () => handleDeleteNoteClick(editorState));
            closeBtn.addEventListener('click', () => closeNoteEditorWithAnimation(editorState));
        }

        function getNoteData(objectId, noteIndex) {
            const objectData = sceneData.get(objectId);
            if (!objectData || !Array.isArray(objectData.notes)) {
                return { title: '', content: '' };
            }
            const note = objectData.notes[noteIndex];
            return note ? { title: note.title || '', content: note.content || '' } : { title: '', content: '' };
        }

        function syncEditorContent(editorState) {
            if (!editorState) return;
            const { objectId, noteIndex, titleInput, contentInput } = editorState;
            const note = getNoteData(objectId, noteIndex);
            if (titleInput && document.activeElement !== titleInput) {
                titleInput.value = note.title;
            }
            if (contentInput && document.activeElement !== contentInput) {
                contentInput.value = note.content;
            }
        }

        function instantiateEditor(object, noteIndex, options = {}) {
            const objectId = object.userData.id;
            const key = getEditorKey(objectId, noteIndex);
            if (openEditors.has(key)) {
                const existing = openEditors.get(key);
                syncEditorContent(existing);
                focusEditor(existing);
                return existing;
            }

            const templateRoot = noteEditorTemplate.content.firstElementChild;
            if (!templateRoot) throw new Error('Note editor template is missing root element.');
            const editorElement = templateRoot.cloneNode(true);
            editorElement.style.display = 'flex';
            editorElement.dataset.editorKey = key;
            editorElement.style.zIndex = `${++nextEditorZ}`;
            const offset = (cascadeIndex++ % 6) * 30;
            editorElement.style.top = `${20 + offset}px`;
            editorElement.style.right = '20px';
            editorElement.style.left = 'auto';

            const titleInput = editorElement.querySelector('.note-title');
            const contentInput = editorElement.querySelector('.note-content');
            const saveBtn = editorElement.querySelector('.note-save-btn');
            const deleteBtn = editorElement.querySelector('.note-delete-btn');
            const closeBtn = editorElement.querySelector('.note-close-btn');
            const dragHandle = editorElement.querySelector('.drag-handle');
            const resizeBL = editorElement.querySelector('.resize-handle-bl');
            const resizeBR = editorElement.querySelector('.resize-handle-br');
            const connector = document.createElement('div');
            connector.className = 'note-connector';
            editorsRoot.appendChild(connector);

            const editorState = {
                key,
                objectId,
                object,
                noteIndex,
                element: editorElement,
                titleInput,
                contentInput,
                saveBtn,
                deleteBtn,
                closeBtn,
                dragHandle,
                resizeBL,
                resizeBR,
                connector,
                intersection: options.intersection || null,
            };

            attachEditorEvents(editorState);
            editorsRoot.appendChild(editorElement);
            openEditors.set(key, editorState);
            syncEditorContent(editorState);
            focusEditor(editorState);
            return editorState;
        }

        function destroyEditor(editorState, { skipAnimation = false } = {}) {
            if (!editorState) return;
            const { element, key, connector } = editorState;
            if (!element) return;
            if (!skipAnimation && element.classList.contains('closing')) return;

            if (document.activeElement === editorState.titleInput || document.activeElement === editorState.contentInput) {
                isTyping = false;
            }

            if (openEditors.has(key)) openEditors.delete(key);
            if (element.parentNode) element.parentNode.removeChild(element);
            if (connector && connector.parentNode) connector.parentNode.removeChild(connector);
        }

        function closeNoteEditorWithAnimation(editorState) {
            if (!editorState || !editorState.element) return;
            const { element } = editorState;
            if (element.classList.contains('closing')) return;
            if (editorState.connector) editorState.connector.style.display = 'none';
            element.classList.add('closing');
            element.addEventListener('animationend', () => {
                element.classList.remove('closing');
                destroyEditor(editorState, { skipAnimation: true });
            }, { once: true });
        }

        function saveNote(editorState) {
            if (!editorState || !editorState.object) return;
            const { object, objectId, noteIndex, titleInput, contentInput, intersection } = editorState;
            const objectData = sceneData.get(objectId);
            if (!objectData) return;

            const notes = Array.isArray(objectData.notes) ? [...objectData.notes] : [];
            notes[noteIndex] = { title: titleInput.value, content: contentInput.value };

            const hasAnyNoteContent = notes.some(note => note && (note.title || note.content));

            if (hasAnyNoteContent && !objectData.decal && intersection && object) {
                const orientation = new THREE.Euler();
                const faceNormal = intersection.normal ? intersection.normal.clone() : object.up.clone();
                const matrix = new THREE.Matrix4().lookAt(
                    intersection.point,
                    intersection.point.clone().sub(faceNormal),
                    object.up
                );
                orientation.setFromRotationMatrix(matrix);
                const inverseMatrix = new THREE.Matrix4().copy(object.matrixWorld).invert();
                objectData.decal = {
                    position: intersection.point.clone().applyMatrix4(inverseMatrix),
                    orientation: { x: orientation.x, y: orientation.y, z: orientation.z },
                };
            } else if (!hasAnyNoteContent) {
                objectData.decal = null;
            }

            objectData.notes = notes;
            sceneData.set(objectId, objectData);
            saveDataToStorage();
            rebuildSceneFromData();
            closeNoteEditorWithAnimation(editorState);
        }

        function handleDeleteNoteClick(editorState) {
            if (!editorState) return;
            const { objectId, noteIndex } = editorState;
            const objectData = sceneData.get(objectId);
            if (!objectData) return;

            confirmMessage.textContent = 'Delete this note?';
            confirmModal.style.display = 'flex';
            deleteAction = () => {
                const notes = Array.isArray(objectData.notes) ? [...objectData.notes] : [];
                notes.splice(noteIndex, 1);
                objectData.notes = notes;
                const hasAnyNoteContent = notes.some(n => (n && (n.title || n.content)));
                if (!hasAnyNoteContent) objectData.decal = null;
                sceneData.set(objectId, objectData);
                saveDataToStorage();
                rebuildSceneFromData();
                for (const otherEditor of Array.from(openEditors.values())) {
                    if (otherEditor.objectId === objectId && otherEditor.key !== editorState.key) {
                        closeNoteEditorWithAnimation(otherEditor);
                    }
                }
                closeNoteEditorWithAnimation(editorState);
                hideModal();
            };
        }

        function openNoteEditor(object, index, options = {}) {
            const intersection = options.intersection || captureIntersectionSnapshot(lastIntersection);
            instantiateEditor(object, index, { intersection });
        }
        
        /** Save object property edits or create a new object. */
        function saveShapeChanges() {
            const newName = shapeNameInput.value.trim();
            if (!newName) {
                shapeNameInput.classList.add('input-error');
                shapeNameInput.focus();
                return;
            }

            const newShape = shapeTypeSelect.value;
            const newColor = shapeColorInput.value;

            if (editingObject) {
                const objectId = editingObject.userData.id;
                const objectData = sceneData.get(objectId);
                if (objectData) {
                    objectData.name = newName;
                    objectData.shape = newShape;
                    objectData.color = newColor;
                    sceneData.set(objectId, objectData);
                }
            } else {
                const newId = crypto.randomUUID();
                sceneData.set(newId, {
                    name: newName,
                    shape: newShape,
                    color: newColor,
                    position: {
                        x: (Math.random() - 0.5) * 20,
                        y: Math.random() * 2 + 1,
                        z: (Math.random() - 0.5) * 20,
                    },
                    notes: [],
                    decal: null,
                });
            }

            saveDataToStorage();
            rebuildSceneFromData();
            closeShapeEditPanel();
        }
        
        /** Confirm delete object flow from shape editor. */
        function handleDeleteObjectFromShapeEditor() {
            if (!editingObject) return;
            confirmMessage.textContent = 'Delete this object and all of its notes?';
            confirmModal.style.display = 'flex';
            deleteAction = () => {
                fadeAndDeleteObject(editingObject);
                hideModal();
                closeShapeEditPanel();
                if (activeObjectUI) activeObjectUI.element.style.display = 'none';
                activeObjectUI = null;
            };
        }

        /** Smoothly fade object and its decal, then remove from scene and storage. */
        function fadeAndDeleteObject(objectToDelete) {
            const objectId = objectToDelete.userData.id;
            const duration = 500;
            const startTime = performance.now();

            // Close any open note tied to this object (before it disappears)
            for (const editorState of Array.from(openEditors.values())) {
                if (editorState.objectId === objectId) {
                    closeNoteEditorWithAnimation(editorState);
                }
            }
            lastIntersection = null;
            if (pendingNoteOpen && pendingNoteOpen.objectId === objectId) {
                pendingNoteOpen = null;
            }

            objectToDelete.traverse((child) => {
                if (child.isMesh) {
                    child.material = child.material.clone();
                    child.material.transparent = true;
                }
            });
            const decal = decals.get(objectId);
            if (decal) decal.material.transparent = true;

            function fade() {
                const progress = Math.min((performance.now() - startTime) / duration, 1);
                const opacity = 1 - progress;
                objectToDelete.traverse((child) => { if (child.isMesh) child.material.opacity = opacity; });
                if (decal) decal.material.opacity = opacity;
                if (progress < 1) requestAnimationFrame(fade);
                else {
                    sceneData.delete(objectId);
                    saveDataToStorage();
                    rebuildSceneFromData();
                }
            }

            requestAnimationFrame(fade);
        }
        function hideModal() { confirmModal.style.display = 'none'; deleteAction = null; }
        
        /** Remove previously placed decal for an object (if any). */
        function removeDecal(objectId) { if(decals.has(objectId)) { const decal = decals.get(objectId); scene.remove(decal); decal.geometry.dispose(); decals.delete(objectId); } }
        /** Place or update a sticky-note style DecalGeometry on the object using saved local transform. */
    function placeOrUpdateDecal(objectId, data) { removeDecal(objectId); const parentObject = objects.get(objectId); if (!parentObject || !data.decal) return; const position = new THREE.Vector3().copy(data.decal.position).applyMatrix4(parentObject.matrixWorld); const orientation = new THREE.Euler().copy(data.decal.orientation); const s = getSetting('notes.decalSize', 0.75); const decalGeom = new THREE.DecalGeometry(parentObject, position, orientation, new THREE.Vector3(s, s, s)); const decal = new THREE.Mesh(decalGeom, decalMaterial); decal.material = decal.material.clone(); decal.material.opacity = getSetting('notes.decalOpacity', 0.9); decal.material.transparent = true; decals.set(objectId, decal); scene.add(decal); }
        
        /** Construct a THREE.Mesh from ObjectData and attach an on-object UI label. */
        function createObjectFromData(data, id) { const geometry = getGeometry(data.shape); const material = new THREE.MeshStandardMaterial({ color: data.color || "#ffffff", roughness: 0.5, metalness: 0.1 }); const mesh = new THREE.Mesh(geometry, material); mesh.position.set(data.position.x, data.position.y, data.position.z); mesh.castShadow = true; mesh.receiveShadow = true; mesh.userData = { id, data }; const objectDiv = document.createElement('div'); objectDiv.className = 'object-ui'; const header = document.createElement('div'); header.className = 'object-ui-header'; const title = document.createElement('h3'); title.textContent = data.name; const editBtn = document.createElement('button'); editBtn.className = 'edit-shape-btn'; editBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M12.854.146a.5.5 0 0 0-.707 0L10.5 1.793 14.207 5.5l1.647-1.646a.5.5 0 0 0 0-.708l-3-3zm.646 6.061L9.793 2.5 3.293 9H3.5a.5.5 0 0 1 .5.5v.5h.5a.5.5 0 0 1 .5.5v.5h.5a.5.5 0 0 1 .5.5v.5h.5a.5.5 0 0 1 .5.5v.207l6.5-6.5zm-7.468 7.468A.5.5 0 0 1 6 13.5V13h-.5a.5.5 0 0 1-.5-.5V12h-.5a.5.5 0 0 1-.5-.5V11h-.5a.5.5 0 0 1-.5-.5V10h-.5a.499.499 0 0 1-.175-.032l-.179.178a.5.5 0 0 0-.11.168l-2 5a.5.5 0 0 0 .65.65l5-2a.5.5 0 0 0 .168-.11l.178-.178z"/></svg>`; editBtn.onclick = (e) => { e.stopPropagation(); showShapeEditPanel(mesh); }; header.appendChild(title); header.appendChild(editBtn); const notesList = document.createElement('ul'); notesList.className = 'notes-list'; (data.notes || []).forEach((note, index) => { const li = document.createElement('li'); li.textContent = note.title || `Note ${index + 1}`; li.onclick = (e) => { e.stopPropagation(); openNoteEditor(mesh, index); }; notesList.appendChild(li); }); const addNoteBtn = document.createElement('button'); addNoteBtn.className = 'add-note-btn'; addNoteBtn.textContent = '+ New Note'; addNoteBtn.onclick = (e) => { e.stopPropagation(); addNewNote(mesh); }; objectDiv.appendChild(header); objectDiv.appendChild(notesList); objectDiv.appendChild(addNoteBtn); const objectLabel = new THREE.CSS2DObject(objectDiv); objectLabel.position.set(0, 1.5, 0); mesh.add(objectLabel); mesh.label = objectLabel; objectLabel.element.style.display = 'none'; scene.add(mesh); objects.set(id, mesh); placeOrUpdateDecal(id, data); }
        /** Populate and show the shape edit panel (or defaults for a new object). */
        function showShapeEditPanel(object = null) {
            editingObject = object;
            shapeNameInput.classList.remove('input-error');

            if (editingObject) {
                const data = editingObject.userData.data;
                shapeNameInput.value = data.name;
                shapeTypeSelect.value = data.shape;
                shapeColorInput.value = data.color;
            } else {
                const existingNames = Array.from(sceneData.values()).map(entry => (entry && entry.name) ? entry.name : '');
                shapeNameInput.value = getNextSequentialName('Shape', existingNames);
                shapeTypeSelect.value = 'Box';
                shapeColorInput.value = '#' + Math.floor(Math.random() * 16777215).toString(16).padStart(6, '0');
            }

            shapeEditPanel.style.display = 'flex';
            wasTypingBeforeShapeEdit = isTyping;
            isTyping = true;

            requestAnimationFrame(() => {
                shapeNameInput.focus();
                if (!editingObject) {
                    shapeNameInput.select();
                }
            });
        }

        /** Hide the shape edit panel and reset state. */
        function closeShapeEditPanel() {
            shapeEditPanel.style.display = 'none';
            editingObject = null;
            shapeNameInput.classList.remove('input-error');
            isTyping = wasTypingBeforeShapeEdit;
            wasTypingBeforeShapeEdit = false;
        }
        
        /** Create and select a new empty note for an object, auto-numbered. */
        function addNewNote(object) {
            const objectId = object.userData.id;
            const objectData = sceneData.get(objectId);
            if (!objectData) return;

            const notes = Array.isArray(objectData.notes) ? [...objectData.notes] : [];
            const existingNames = notes.map(note => (note && note.title) ? note.title : '');
            const suggestedTitle = getNextSequentialName('Note', existingNames);

            openNamePrompt({
                title: 'Name your note',
                defaultValue: suggestedTitle,
                confirmLabel: 'Create Note',
                onConfirm: (noteTitle) => {
                    const updatedNotes = [...notes, { title: noteTitle, content: '' }];
                    objectData.notes = updatedNotes;
                    sceneData.set(objectId, objectData);
                    saveDataToStorage();
                    rebuildSceneFromData();
                    pendingNoteOpen = { objectId, noteIndex: updatedNotes.length - 1, intersection: captureIntersectionSnapshot(lastIntersection) };
                },
            });
        }

        /**
         * Keyboard movement with simple momentum. Disabled while typing to avoid accidental motion.
         */
        function handleCameraMovement() { const moveDirection = new THREE.Vector3(); if (!isTyping) { const forward = new THREE.Vector3(); camera.getWorldDirection(forward); const right = new THREE.Vector3().crossVectors(forward, camera.up); if (keyState['KeyW'] || keyState['ArrowUp']) moveDirection.add(forward); if (keyState['KeyS'] || keyState['ArrowDown']) moveDirection.sub(forward); if (keyState['KeyA'] || keyState['ArrowLeft']) moveDirection.sub(right); if (keyState['KeyD'] || keyState['ArrowRight']) moveDirection.add(right); if (keyState['KeyE']) moveDirection.y += 1; if (keyState['KeyQ']) moveDirection.y -= 1; } if (moveDirection.lengthSq() > 0) cameraVelocity.copy(moveDirection.normalize().multiplyScalar(moveSpeed)); camera.position.add(cameraVelocity); controls.target.add(cameraVelocity); cameraVelocity.multiplyScalar(DAMPING); }
        
        /**
         * Raycast click on objects to toggle their on-object UI.
         * Ignores clicks that originate from UI elements or while dragging the camera.
         */
        function onObjectClick(event) {
            if (isDraggingCamera) return;
            const uiElements = document.querySelectorAll('.object-ui, .note-editor, #shape-edit-panel, #add-object-btn, #confirm-modal, #name-prompt-modal');
            for(const el of uiElements) {
                if (el.contains(event.target)) return;
            }
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(Array.from(objects.values()), true);
            
            if (intersects.length > 0) {
                lastIntersection = intersects[0];
                let clickedObject = lastIntersection.object;
                while(clickedObject.parent && !clickedObject.userData.id) {
                    clickedObject = clickedObject.parent;
                }
                if(clickedObject.userData.id && objects.has(clickedObject.userData.id)) {
                    if (selectedObject && selectedObject.userData.id === clickedObject.userData.id) return;
                    if (activeObjectUI) activeObjectUI.element.style.display = 'none';
                    selectedObject = objects.get(clickedObject.userData.id);
                    activeObjectUI = selectedObject.label;
                    activeObjectUI.element.style.display = 'block';
                }
            } else {
                if (activeObjectUI) {
                    activeObjectUI.element.style.display = 'none';
                    activeObjectUI = null;
                }
                selectedObject = null;
                lastIntersection = null;
            }
        }

        /** Hide on-object UI when moving too far from the selection to reduce clutter. */
    function checkObjectUIDistance() { if (activeObjectUI && selectedObject) { const distance = camera.position.distanceTo(selectedObject.position); const cutoff = getSetting('ui.labelHideDistance', 20); if (distance > cutoff) { activeObjectUI.element.style.display = 'none'; activeObjectUI = null; selectedObject = null; } } }
        /** Easing helpers (comfort-first). */
        function easeInOutCubic(t) { return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2; }
        function easeOutCubic(t) { return 1 - Math.pow(1 - t, 3); }
        function easeInOutQuad(t) { return t < 0.5 ? 2*t*t : 1 - Math.pow(-2*t + 2, 2)/2; }
        function resolveEasing(name) {
            switch (name) {
                case 'easeOutCubic': return easeOutCubic;
                case 'easeInOutQuad': return easeInOutQuad;
                case 'easeInOutCubic':
                default: return easeInOutCubic;
            }
        }
        /** Smooth camera tween to cycle through objects on Tab. */
        function cycleToObject() {
            const objectArray = Array.from(objects.values());
            if (objectArray.length === 0) return;
            // If a cycle is already in progress, cancel it and start a new one from the current pose
            if (isCycling) isCycling = false;
            isCycling = true;
            cycleIndex = (cycleIndex + 1) % objectArray.length;

            const targetObject = objectArray[cycleIndex];
            const targetPosition = targetObject.position.clone();

            // Maintain viewing direction relative to target: keep about 10 units away from the object.
            const direction = new THREE.Vector3().subVectors(camera.position, targetPosition).normalize();
            const lockDistance = getSetting('cycle.distance', 10);
            const newCameraPosition = new THREE.Vector3().addVectors(targetPosition, direction.multiplyScalar(lockDistance));

            const duration = getSetting('cycle.durationMs', 350); // ms â€“ quick, comfortable lock-on
            const startPos = camera.position.clone();
            const startTarget = controls.target.clone();
            const startTime = performance.now();
            const easingFn = resolveEasing(getSetting('cycle.easing', 'easeInOutCubic'));

            // Prepare selection/UI immediately so the user perceives focus change
            if (activeObjectUI) activeObjectUI.element.style.display = 'none';
            selectedObject = targetObject;
            activeObjectUI = selectedObject.label;
            if (activeObjectUI) activeObjectUI.element.style.display = 'block';

            function step(now) {
                if (!isCycling) return;
                const t = Math.min(1, (now - startTime) / duration);
                const e = easingFn(t);
                camera.position.lerpVectors(startPos, newCameraPosition, e);
                controls.target.lerpVectors(startTarget, targetPosition, e);
                controls.update();
                if (t < 1) requestAnimationFrame(step);
                else {
                    // Snap to exact final state and zero momentum so we don't drift
                    camera.position.copy(newCameraPosition);
                    controls.target.copy(targetPosition);
                    cameraVelocity.set(0, 0, 0);
                    controls.update();
                    isCycling = false;
                }
            }
            requestAnimationFrame(step);
        }
        /** Keep composer sizes in sync with viewport. */
        function onWindowResize() { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); labelRenderer.setSize(window.innerWidth, window.innerHeight); composer.setSize(window.innerWidth, window.innerHeight); }
        
        /**
         * Draw a line from the editor panel to the object's screen position to support spatial association.
         */
        function updateLineConnectors() {
            const show = getSetting('ui.showConnector', true);
            for (const editorState of openEditors.values()) {
                const { element, object, connector } = editorState;
                if (!connector) continue;

                if (!show || !object || !element || element.style.display === 'none' || element.classList.contains('closing')) {
                    connector.style.display = 'none';
                    continue;
                }

                const projected = object.position.clone().project(camera);
                if (projected.z < -1 || projected.z > 1) {
                    connector.style.display = 'none';
                    continue;
                }
                const screenX = (projected.x * 0.5 + 0.5) * window.innerWidth;
                const screenY = (-projected.y * 0.5 + 0.5) * window.innerHeight;
                const uiRect = element.getBoundingClientRect();
                const uiX = uiRect.left + uiRect.width / 2;
                const uiY = uiRect.top + uiRect.height / 2;
                const dx = screenX - uiX;
                const dy = screenY - uiY;
                const length = Math.hypot(dx, dy);
                const angle = Math.atan2(dy, dx) * (180 / Math.PI);
                connector.style.left = `${uiX}px`;
                connector.style.top = `${uiY}px`;
                connector.style.width = `${length}px`;
                connector.style.transform = `rotate(${angle}deg)`;
                connector.style.display = 'block';
                connector.style.zIndex = `${Math.max(0, parseInt(element.style.zIndex || `${nextEditorZ}`, 10) - 1)}`;
            }
        }

        /** Main render loop. */
        function animate() {
            requestAnimationFrame(animate);
            if(!isCycling) handleCameraMovement();
            controls.update();
            checkObjectUIDistance();
            updateLineConnectors();
            filmPass.uniforms.time.value = clock.getElapsedTime();
            composer.render();
            labelRenderer.render(scene, camera);
        }

        // Initial call
        init();
    </script>
</body>
</html>

